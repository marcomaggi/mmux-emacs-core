\input texinfo.tex
@c %**start of header
@setfilename mmux-emacs-core.info
@settitle MMUX Emacs Core
@c %**end of header

@include version.texi
@include macros.texi
@include elisp-macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      @mmux{} Emacs Core

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    @mmux{} Emacs Core

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmux-emacs-core

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2020

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              MMUX_EMACS_CORE
@set PackagePkgconfigModule             @code{mmux-emacs-core}
@set PackageLibsVar                     @env{MMUX_EMACS_CORE_LIBS}
@set PackageCflagsVar                   @env{MMUX_EMACS_CORE_CFLAGS}

@set PackageLibstem                     @file{mmux-emacs-core}
@set PackageSharedLibraryBasename       @file{libmmux-emacs-core}

@set PackageEmacsModule                 @file{mmec}
@set PackageHeader                      mmux-emacs-core.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set PackageApiCPrefixLower             mmec_
@set PackageApiCPrefixUpper             MMEC_
@set PackageApiElispPrefix              mmec-

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@set RequiredEmacsVersion       26+

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------


@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This package installs a @gnu{} Emacs module, written in Emacs Lisp, on top of a C11 language library
implementing an Emacs dynamic module; these modules provide basic infrastructure to write dynamic
modules for Emacs, especially interfaces to foreign C language libraries.

This package supports @posix{} platforms.  This package is meant to work with @gnu{} Emacs version
@value{RequiredEmacsVersion}.  This package depends upon the external packages: @code{cl-lib}. To
run the test suite: this package requires the @code{ert} package.

This package is distributed under the terms of the @gnu{} General Public License (@gpl{}).

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}@*

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmux-emacs-core: (mmux-emacs-core).  MMUX Emacs Core a core library.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* constants::                   Constant values.
* ctypes::                      Object wrappers for C language types.
* bytevectors::                 Bytevector objects.
* errors::                      How errors are signalled.
* capi::                        C language programming interface.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

External documents

* modules: (elisp)Writing Dynamic Modules.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}; this package installs a @gnu{}
Emacs module, written in Emacs Lisp, on top of a C11 language library implementing an Emacs dynamic
module; these modules provide basic infrastructure to write dynamic modules for Emacs, especially
interfaces to foreign C language libraries.

This package supports @posix{} platforms.  This package is meant to work with @gnu{} Emacs version
@value{RequiredEmacsVersion}.  This package depends upon the external packages: @code{cl-lib}.  To
run the test suite: this package requires the @code{ert} package.

@value{PACKAGE} installs various elisp modules, the main one being @value{PackageEmacsModule}; it
also installs a C language shared library with basename @value{PackageSharedLibraryBasename} (using
the @gnu{} Libtool infrastructure).  All the elisp definition names are prefixed with
@code{@value{PackageApiElispPrefix}}.  The C language shared library is installed under
@samp{$libdir}, for example:

@center @file{/usr/local/lib64}

@noindent
while the elisp module goes under @samp{$lispdir}, for example:

@center @file{/usr/local/share/emacs/site-lisp}

@noindent
so to load the module (under an Emacs installation with dynamic modules enabled) we should do
something like:

@lisp
(add-to-list 'load-path "/usr/local/lib64"
                        "/usr/local/share/emacs/site-lisp")
(require 'mmec)
@end lisp

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
It might be possible that we want to write a C language library making use of the facilities of this
package; so @value{PACKAGE} installs the single header file @value{PackageHeaderFile}.  All the C
language function names in the @api{} are prefixed with @code{@value{PackageApiCPrefixLower}}; all
the C language preprocessor symbol names are prefixed with @code{@value{PackageApiCPrefixUpper}};
all the type names are prefixed with @code{@value{PackageApiCPrefixLower}} and suffixed with
@code{_t}.

@menu
* overview linking::            Linking code with the library.
@end menu

@include overview-linking.texi

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@defun mmec-version-string
Return a string representing the interface version number.
@end defun


@defun mmec-version-interface-current
Return an integer representing the library interface current number.
@end defun


@defun mmec-version-interface-revision
Return an integer representing the library interface current revision number.
@end defun


@defun mmec-version-interface-age
Return an integer representing the library interface current age.
@end defun

@c page
@node constants
@chapter Constant values


@menu
* constants sizeof::            Size of common C language types.
* constants limits::            Ranges representable by C language types.
* constants float::             Constants related to floating-point numbers.
@end menu

@c page
@node constants sizeof
@section Size of common C language types


@deftypevr {Constant} integer mmec-SIZEOF_CHAR
Value of type @objtype{integer} representing the size of @code{char} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_SIGNED_CHAR
Value of type @objtype{integer} representing the size of @code{signed char} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UNSIGNED_CHAR
Value of type @objtype{integer} representing the size of @code{unsigned char} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_WCHAR
Value of type @objtype{integer} representing the size of @code{wchar_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_SIGNED_SHORT_INT
Value of type @objtype{integer} representing the size of @code{signed short int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UNSIGNED_SHORT_INT
Value of type @objtype{integer} representing the size of @code{signed short int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_SIGNED_INT
Value of type @objtype{integer} representing the size of @code{signed int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UNSIGNED_INT
Value of type @objtype{integer} representing the size of @code{signed int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UNSIGNED_INT
Value of type @objtype{integer} representing the size of @code{unsigned int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UNUNSIGNED_INT
Value of type @objtype{integer} representing the size of @code{unsigned int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_SIGNED_LONG_INT
Value of type @objtype{integer} representing the size of @code{signed long int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UNSIGNED_LONG_INT
Value of type @objtype{integer} representing the size of @code{signed long int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UNSIGNED_LONG_INT
Value of type @objtype{integer} representing the size of @code{unsigned long int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UNUNSIGNED_LONG_INT
Value of type @objtype{integer} representing the size of @code{unsigned long int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_SIGNED_LONG_LONG_INT
Value of type @objtype{integer} representing the size of @code{signed long long int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UNSIGNED_LONG_LONG_INT
Value of type @objtype{integer} representing the size of @code{signed long long int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UNSIGNED_LONG_LONG_INT
Value of type @objtype{integer} representing the size of @code{unsigned long long int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UNUNSIGNED_LONG_LONG_INT
Value of type @objtype{integer} representing the size of @code{unsigned long long int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_SIZE_T
Value of type @objtype{integer} representing the size of @code{size_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_SSIZE_T
Value of type @objtype{integer} representing the size of @code{ssize_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_INTMAX_T
Value of type @objtype{integer} representing the size of @code{intmax_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UINTMAX_T
Value of type @objtype{integer} representing the size of @code{uintmax_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_INT8_T
Value of type @objtype{integer} representing the size of @code{int8_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UINT8_T
Value of type @objtype{integer} representing the size of @code{uint8_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_INT16_T
Value of type @objtype{integer} representing the size of @code{int16_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UINT16_T
Value of type @objtype{integer} representing the size of @code{uint16_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_INT32_T
Value of type @objtype{integer} representing the size of @code{int32_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UINT32_T
Value of type @objtype{integer} representing the size of @code{uint32_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_INT64_T
Value of type @objtype{integer} representing the size of @code{int64_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UINT64_T
Value of type @objtype{integer} representing the size of @code{uint64_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_FLOAT
Value of type @objtype{integer} representing the size of @code{float} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_DOUBLE
Value of type @objtype{integer} representing the size of @code{double} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_LONG_DOUBLE
Value of type @objtype{integer} representing the size of @code{long double} measured in bytes.
@end deftypevr

@c page
@node constants limits
@section Ranges representable by C language types


@deftypevr {Constant} mmec-char mmec-CHAR_MIN
Value of type @objtype{mmec-char} representing the minimum value representable by a @code{char}.
@end deftypevr


@deftypevr {Constant} mmec-char mmec-CHAR_MAX
Value of type @objtype{mmec-char} representing the maximum value representable by a @code{char}.
@end deftypevr


@deftypevr {Constant} mmec-schar mmec-SCHAR_MIN
Value of type @objtype{mmec-schar} representing the minimum value representable by a @code{signed
char}.
@end deftypevr


@deftypevr {Constant} mmec-schar mmec-SCHAR_MAX
Value of type @objtype{mmec-schar} representing the maximum value representable by a @code{signed
char}.
@end deftypevr


@deftypevr {Constant} mmec-uchar mmec-UCHAR_MIN
Value of type @objtype{mmec-uchar} representing the minimum value representable by a @code{unsigned
char}.
@end deftypevr


@deftypevr {Constant} mmec-uchar mmec-UCHAR_MAX
Value of type @objtype{mmec-uchar} representing the maximum value representable by a @code{unsigned
char}.
@end deftypevr


@deftypevr {Constant} mmec-sshrt mmec-SHRT_MIN
Value of type @objtype{mmec-sshrt} representing the minimum value representable by a @code{signed
short int}.
@end deftypevr


@deftypevr {Constant} mmec-sshrt mmec-SHRT_MAX
Value of type @objtype{mmec-sshrt} representing the maximum value representable by a @code{signed
short int}.
@end deftypevr


@deftypevr {Constant} mmec-ushrt mmec-USHRT_MIN
Value of type @objtype{mmec-ushrt} representing the minimum value representable by a @code{unsigned
short int}.
@end deftypevr


@deftypevr {Constant} mmec-ushrt mmec-USHRT_MAX
Value of type @objtype{mmec-ushrt} representing the maximum value representable by a @code{unsigned
short int}.
@end deftypevr


@deftypevr {Constant} mmec-sint mmec-INT_MIN
Value of type @objtype{mmec-sint} representing the minimum value representable by a @code{signed
int}.
@end deftypevr


@deftypevr {Constant} mmec-sint mmec-INT_MAX
Value of type @objtype{mmec-sint} representing the maximum value representable by a @code{signed
int}.
@end deftypevr


@deftypevr {Constant} mmec-uint mmec-UINT_MIN
Value of type @objtype{mmec-uint} representing the minimum value representable by a @code{unsigned
int}.
@end deftypevr


@deftypevr {Constant} mmec-uint mmec-UINT_MAX
Value of type @objtype{mmec-uint} representing the maximum value representable by a @code{unsigned
int}.
@end deftypevr


@deftypevr {Constant} mmec-slong mmec-LONG_MIN
Value of type @objtype{mmec-slong} representing the minimum value representable by a @code{signed
long int}.
@end deftypevr


@deftypevr {Constant} mmec-slong mmec-LONG_MAX
Value of type @objtype{mmec-slong} representing the maximum value representable by a @code{signed
long int}.
@end deftypevr


@deftypevr {Constant} mmec-ulong mmec-ULONG_MIN
Value of type @objtype{mmec-ulong} representing the minimum value representable by a @code{unsigned
long int}.
@end deftypevr


@deftypevr {Constant} mmec-ulong mmec-ULONG_MAX
Value of type @objtype{mmec-ulong} representing the maximum value representable by a @code{unsigned
long int}.
@end deftypevr


@deftypevr {Constant} mmec-sllong mmec-LLONG_MIN
Value of type @objtype{mmec-sllong} representing the minimum value representable by a @code{signed
long long int}.
@end deftypevr


@deftypevr {Constant} mmec-sllong mmec-LLONG_MAX
Value of type @objtype{mmec-sllong} representing the maximum value representable by a @code{signed
long long int}.
@end deftypevr


@deftypevr {Constant} mmec-ullong mmec-ULLONG_MIN
Value of type @objtype{mmec-ullong} representing the minimum value representable by a @code{unsigned
long long int}.
@end deftypevr


@deftypevr {Constant} mmec-ullong mmec-ULLONG_MAX
Value of type @objtype{mmec-ullong} representing the maximum value representable by a @code{unsigned
long long int}.
@end deftypevr


@deftypevr {Constant} mmec-wchar mmec-WCHAR_MIN
Value of type @objtype{mmec-wchar} representing the minimum value representable by a @code{wchar_t}.
@end deftypevr


@deftypevr {Constant} mmec-wchar mmec-WCHAR_MAX
Value of type @objtype{mmec-wchar} representing the maximum value representable by a @code{wchar_t}.
@end deftypevr


@deftypevr {Constant} mmec-ssize mmec-SSIZE_T_MIN
Value of type @objtype{mmec-ssize} representing the minimum value representable by a @code{ssize_t}.
@end deftypevr


@deftypevr {Constant} mmec-ssize mmec-SSIZE_T_MAX
Value of type @objtype{mmec-ssize} representing the maximum value representable by a @code{ssize_t}.
@end deftypevr


@deftypevr {Constant} mmec-usize mmec-SIZE_T_MIN
Value of type @objtype{mmec-usize} representing the minimum value representable by a @code{size_t}.
@end deftypevr


@deftypevr {Constant} mmec-usize mmec-SIZE_T_MAX
Value of type @objtype{mmec-usize} representing the maximum value representable by a @code{size_t}.
@end deftypevr


@deftypevr {Constant} mmec-sintmax mmec-INTMAX_MIN
Value of type @objtype{mmec-sintmax} representing the minimum value representable by a
@code{intmax_t}.
@end deftypevr


@deftypevr {Constant} mmec-sintmax mmec-INTMAX_MAX
Value of type @objtype{mmec-sintmax} representing the maximum value representable by a
@code{intmax_t}.
@end deftypevr


@deftypevr {Constant} mmec-uintmax mmec-UINTMAX_MIN
Value of type @objtype{mmec-uintmax} representing the maximum value representable by a
@code{uintmax_t}.
@end deftypevr


@deftypevr {Constant} mmec-sint8 mmec-INT8_MIN
Value of type @objtype{mmec-sint8} representing the minimum value representable by a @code{int8_t}.
@end deftypevr


@deftypevr {Constant} mmec-sint8 mmec-INT8_MAX
Value of type @objtype{mmec-sint8} representing the maximum value representable by a @code{int8_t}.
@end deftypevr


@deftypevr {Constant} mmec-uint8 mmec-UINT8_MIN
Value of type @objtype{mmec-uint8} representing the minimum value representable by a @code{uint8_t}.
@end deftypevr


@deftypevr {Constant} mmec-uint8 mmec-UINT8_MAX
Value of type @objtype{mmec-uint8} representing the maximum value representable by a @code{uint8_t}.
@end deftypevr


@deftypevr {Constant} mmec-sint16 mmec-INT16_MIN
Value of type @objtype{mmec-sint16} representing the minimum value representable by a
@code{int16_t}.
@end deftypevr


@deftypevr {Constant} mmec-sint16 mmec-INT16_MAX
Value of type @objtype{mmec-sint16} representing the maximum value representable by a
@code{int16_t}.
@end deftypevr


@deftypevr {Constant} mmec-uint16 mmec-UINT16_MIN
Value of type @objtype{mmec-uint16} representing the minimum value representable by a
@code{uint16_t}.
@end deftypevr


@deftypevr {Constant} mmec-uint16 mmec-UINT16_MAX
Value of type @objtype{mmec-uint16} representing the maximum value representable by a
@code{uint16_t}.
@end deftypevr


@deftypevr {Constant} mmec-sint32 mmec-INT32_MIN
Value of type @objtype{mmec-sint32} representing the minimum value representable by a
@code{int32_t}.
@end deftypevr


@deftypevr {Constant} mmec-sint32 mmec-INT32_MAX
Value of type @objtype{mmec-sint32} representing the maximum value representable by a
@code{int32_t}.
@end deftypevr


@deftypevr {Constant} mmec-uint32 mmec-UINT32_MIN
Value of type @objtype{mmec-uint32} representing the minimum value representable by a
@code{uint32_t}.
@end deftypevr


@deftypevr {Constant} mmec-uint32 mmec-UINT32_MAX
Value of type @objtype{mmec-uint32} representing the maximum value representable by a
@code{uint32_t}.
@end deftypevr


@deftypevr {Constant} mmec-sint64 mmec-INT64_MIN
Value of type @objtype{mmec-sint64} representing the minimum value representable by a
@code{int64_t}.
@end deftypevr


@deftypevr {Constant} mmec-sint64 mmec-INT64_MAX
Value of type @objtype{mmec-sint64} representing the maximum value representable by a
@code{int64_t}.
@end deftypevr


@deftypevr {Constant} mmec-uint64 mmec-UINT64_MIN
Value of type @objtype{mmec-uint64} representing the minimum value representable by a
@code{uint64_t}.
@end deftypevr


@deftypevr {Constant} mmec-uint64 mmec-UINT64_MAX
Value of type @objtype{mmec-uint64} representing the maximum value representable by a
@code{uint64_t}.
@end deftypevr


@deftypevr {Constant} mmec-float mmec-FLT_MIN
Value of type @objtype{mmec-float} representing the system constant @code{FLT_MIN}.
@end deftypevr


@deftypevr {Constant} mmec-float mmec-FLT_MAX
Value of type @objtype{mmec-float} representing the system constant @code{FLT_MAX}.
@end deftypevr


@deftypevr {Constant} mmec-double mmec-DBL_MIN
Value of type @objtype{mmec-double} representing the system constant @code{DBL_MIN}.
@end deftypevr


@deftypevr {Constant} mmec-double mmec-DBL_MAX
Value of type @objtype{mmec-double} representing the system constant @code{DBL_MAX}.
@end deftypevr


@deftypevr {Constant} mmec-ldouble mmec-LDBL_MIN
Value of type @objtype{mmec-ldouble} representing the system constant @code{LDBL_MIN}.
@end deftypevr


@deftypevr {Constant} mmec-ldouble mmec-LDBL_MAX
Value of type @objtype{mmec-ldouble} representing the system constant @code{LDBL_MAX}.
@end deftypevr

@c page
@node constants float
@section Constants related to floating--point numbers


@deftypevr {Constant} integer mmec-FLT_ROUNDS
Value of type @objtype{integer} the system constant @code{FLT_ROUNDS}.
@end deftypevr


@deftypevr {Constant} integer mmec-FLT_RADIX
Value of type @objtype{integer} representing the system constant @code{FLT_RADIX}.
@end deftypevr


@deftypevr {Constant} integer mmec-FLT_MANT_DIG
Value of type @objtype{integer} representing the system constant @code{FLT_MANT_DIG}.
@end deftypevr


@deftypevr {Constant} integer mmec-DBL_MANT_DIG
Value of type @objtype{integer} representing the system constant @code{DBL_MANT_DIG}.
@end deftypevr


@deftypevr {Constant} integer mmec-LDBL_MANT_DIG
Value of type @objtype{integer} representing the system constant @code{LDBL_MANT_DIG}.
@end deftypevr


@deftypevr {Constant} integer mmec-FLT_DIG
Value of type @objtype{integer} representing the system constant @code{FLT_DIG}.
@end deftypevr


@deftypevr {Constant} integer mmec-DBL_DIG
Value of type @objtype{integer} representing the system constant @code{DBL_DIG}.
@end deftypevr


@deftypevr {Constant} integer mmec-LDBL_DIG
Value of type @objtype{integer} representing the system constant @code{LDBL_DIG}.
@end deftypevr


@deftypevr {Constant} integer mmec-FLT_MIN_EXP
Value of type @objtype{integer} representing the system constant @code{FLT_MIN_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-DBL_MIN_EXP
Value of type @objtype{integer} representing the system constant @code{DBL_MIN_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-LDBL_MIN_EXP
Value of type @objtype{integer} representing the system constant @code{LDBL_MIN_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-FLT_MIN_10_EXP
Value of type @objtype{integer} representing the system constant @code{FLT_MIN_10_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-DBL_MIN_10_EXP
Value of type @objtype{integer} representing the system constant @code{DBL_MIN_10_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-LDBL_MIN_10_EXP
Value of type @objtype{integer} representing the system constant @code{LDBL_MIN_10_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-FLT_MAX_EXP
Value of type @objtype{integer} representing the system constant @code{FLT_MAX_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-DBL_MAX_EXP
Value of type @objtype{integer} representing the system constant @code{DBL_MAX_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-LDBL_MAX_EXP
Value of type @objtype{integer} representing the system constant @code{LDBL_MAX_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-FLT_MAX_10_EXP
Value of type @objtype{integer} representing the system constant @code{FLT_MAX_10_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-DBL_MAX_10_EXP
Value of type @objtype{integer} representing the system constant @code{DBL_MAX_10_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-LDBL_MAX_10_EXP
Value of type @objtype{integer} representing the system constant @code{LDBL_MAX_10_EXP}.
@end deftypevr


@deftypevr {Constant} mmec-float mmec-FLT_EPSILON
Value of type @objtype{mmec-float} representing the system constant @code{FLT_EPSILON}.
@end deftypevr


@deftypevr {Constant} mmec-double mmec-DBL_EPSILON
Value of type @objtype{mmec-double} representing the system constant @code{DBL_EPSILON}.
@end deftypevr


@deftypevr {Constant} mmec-ldouble mmec-LDBL_EPSILON
Value of type @objtype{mmec-ldouble} representing the system constant @code{LDBL_EPSILON}.
@end deftypevr

@c page
@node ctypes
@chapter Object wrappers for C language types.


@value{PACKAGE} defines elisp data types in the module @value{PackageEmacsModule}.  Many wrappers
for integer types are implemented for safety of writing interfaces to C language libraries and for
better dispatching of multimethods.

@quotation
@strong{NOTE} At the time of this writing (Feb 2, 2020) @gnu{} Emacs version 26 internally
represents exact integer objects with values of type C language @code{intmax_t}, but not the whole
range of such type is available.
@end quotation

@menu
* ctypes typedefs::             Object type definitions.
* ctypes comparison::           Comparison operations.
@end menu

@c page
@node ctypes typedefs
@section Object type definitions


@menu
* ctypes typedefs base::        Base type definitions.
* ctypes typedefs char::        Wrapper for @code{char}.
* ctypes typedefs schar::       Wrapper for @code{signed char}.
* ctypes typedefs uchar::       Wrapper for @code{unsigned char}.
* ctypes typedefs wchar::       Wrapper for @code{wchar_t}.
* ctypes typedefs sshrt::       Wrapper for @code{signed short int}.
* ctypes typedefs ushrt::       Wrapper for @code{unsigned short int}.
* ctypes typedefs sint::        Wrapper for @code{signed int}.
* ctypes typedefs uint::        Wrapper for @code{unsigned int}.
* ctypes typedefs slong::       Wrapper for @code{signed long int}.
* ctypes typedefs ulong::       Wrapper for @code{unsigned long int}.
* ctypes typedefs sllong::      Wrapper for @code{signed long long int}.
* ctypes typedefs ullong::      Wrapper for @code{unsigned long long int}.
* ctypes typedefs ssize::       Wrapper for @code{ssize_t}.
* ctypes typedefs usize::       Wrapper for @code{size_t}.
* ctypes typedefs sintmax::     Wrapper for @code{intmax_t}.
* ctypes typedefs uintmax::     Wrapper for @code{uintmax_t}.
* ctypes typedefs ptrdiff::     Wrapper for @code{ptrdiff_t}.
* ctypes typedefs sint8::       Wrapper for @code{int8_t}.
* ctypes typedefs uint8::       Wrapper for @code{uint8_t}.
* ctypes typedefs sint16::      Wrapper for @code{int16_t}.
* ctypes typedefs uint16::      Wrapper for @code{uint16_t}.
* ctypes typedefs sint32::      Wrapper for @code{int32_t}.
* ctypes typedefs uint32::      Wrapper for @code{uint32_t}.
* ctypes typedefs sint64::      Wrapper for @code{int64_t}.
* ctypes typedefs uint64::      Wrapper for @code{uint64_t}.
* ctypes typedefs float::       Wrapper for @code{float}.
* ctypes typedefs double::      Wrapper for @code{double}.
* ctypes typedefs ldouble::     Wrapper for @code{long double}.
@end menu

@c ------------------------------------------------------------------------

@macro ElispNumberValueDefinition{ETYPESTEM, CTYPE, EANCESTORTYPESTEM, ENORMTYPESTEM, INTREPDESCR}
@ElispNumberValueTypeDefinition{\ETYPESTEM\, \CTYPE\, \EANCESTORTYPESTEM\, \ENORMTYPESTEM\, \INTREPDESCR\}
@ElispNumberValueDefaultMethods{\ETYPESTEM\, \CTYPE\, \EANCESTORTYPESTEM\, \ENORMTYPESTEM\, \INTREPDESCR\}
@ElispNumberValueSpecialisedMethods{\ETYPESTEM\, \CTYPE\, \EANCESTORTYPESTEM\, \ENORMTYPESTEM\, \INTREPDESCR\}
@ElispNumberValueFitsFunctions{\ETYPESTEM\, \CTYPE\, \EANCESTORTYPESTEM\, \ENORMTYPESTEM\, \INTREPDESCR\}
@end macro

@c ------------------------------------------------------------------------

@macro ElispNumberValueTypeDefinition{ETYPESTEM, CTYPE, EANCESTORTYPESTEM, ENORMTYPESTEM, INTREPDESCR}
@deftp {Object Type} mmec-\ETYPESTEM\
@deftpx {Parent Type} mmec-\EANCESTORTYPESTEM\
Object wrapper for the C language type @code{\CTYPE\}.
@end deftp


@defun mmec-\ETYPESTEM\-p @var{obj}
Return true if @var{obj} is an instance of @objtype{mmec-\ETYPESTEM\}, otherwise return false.
@end defun


@defun mmec-\ETYPESTEM\-obj @var{OBJ}
Given an instance of @objtype{mmec-\ETYPESTEM\}: return its internal representation as
\INTREPDESCR\.
@end defun

@end macro

@c ------------------------------------------------------------------------

@macro ElispNumberValueDefaultMethods{ETYPESTEM, CTYPE, EANCESTORTYPESTEM, ENORMTYPESTEM, INTREPDESCR}
@deffn {Generic Function} mmec-\ETYPESTEM\ @var{INIT}
Constructor for number of objects of type @objtype{mmec-\ETYPESTEM\}.  The argument @var{INIT} must be a
number value.
@end deffn


@deffn {Method} mmec-\ETYPESTEM\ (@var{INIT} mmec-\ETYPESTEM\)
This is the copy constructor implemented as method.  This method creates a duplicate of the
@var{INIT} value, but it reuses the internal representation (which is immutable).
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro ElispNumberValueSpecialisedMethods{ETYPESTEM, CTYPE, EANCESTORTYPESTEM, ENORMTYPESTEM, INTREPDESCR}
@deffn {Method} mmec-\ETYPESTEM\ (@var{INIT} integer)
Specialised constructor for number values of type @objtype{mmec-\ETYPESTEM\}.

This constructor normalises the initialisation argument to an object of type @objtype{mmec-\ENORMTYPESTEM\},
then it checks if the range is valid: if it is is builds an object of type @objtype{mmec-\ETYPESTEM\},
otherwise it raises the error condition @code{mmec-error-value-out-of-range}.
@end deffn


@deffn {Method} mmec-\ETYPESTEM\ (@var{INIT} float)
Specialised constructor for number values of type @objtype{mmec-\ETYPESTEM\}.

This constructor normalises the initialisation argument to an object of type @objtype{mmec-\ENORMTYPESTEM\},
then it checks if the range is valid: if it is is builds an object of type @objtype{mmec-\ETYPESTEM\},
otherwise it raises the error condition @code{mmec-error-value-out-of-range}.
@end deffn


@deffn {Method} mmec-\ETYPESTEM\ (@var{INIT} mmec-\EANCESTORTYPESTEM\)
Specialised constructor for number values of type @objtype{mmec-\ETYPESTEM\}.

This constructor normalises the initialisation argument to an object of type @objtype{mmec-\ENORMTYPESTEM\},
then it checks if the range is valid: if it is is builds an object of type @objtype{mmec-\ETYPESTEM\},
otherwise it raises the error condition @code{mmec-error-value-out-of-range}.
@end deffn


@deffn {Method} mmec-\ETYPESTEM\ (@var{INIT} mmec-number)
Specialised constructor for number values of type @objtype{mmec-\ETYPESTEM\}.

This constructor signals that the given initialisation argument is invalid by raising the condition
@code{mmec-error-unsupported-init-type}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro ElispNumberValueFitsFunctions{ETYPESTEM, CTYPE, EANCESTORTYPESTEM, ENORMTYPESTEM, INTREPDESCR}
@deffn {Generic Function} mmec-fits-\ETYPESTEM\-p @var{INIT}
Generic function that returns true if the argument @var{INIT} would fit a representation as
@objtype{mmec-\ETYPESTEM\}; otherwise it returns false.  The argument @var{INIT} must be a number
value.
@end deffn


@deffn {Method} mmec-fits-\ETYPESTEM\-p (@var{INIT} mmec-\EANCESTORTYPESTEM\)
@deffnx {Method} mmec-fits-\ETYPESTEM\-p (@var{INIT} integer)
@deffnx {Method} mmec-fits-\ETYPESTEM\-p (@var{INIT} float)
Specialised method that converts @var{INIT} into a value of type @objtype{mmec-\ENORMTYPESTEM\},
then returns true if the converted value would fit a representation as @objtype{mmec-\ETYPESTEM\};
otherwise it returns false.
@end deffn

@end macro

@c page
@node ctypes typedefs base
@subsection Base type definitions


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.  All the
following types are to be considered ``abstract'', so we must not instantiate them.


@deftp {Abstract Object Type} mmec-number
Base type of all the custom number types defined by this module.
@end deftp


@deftp {Abstract Object Type} mmec-integer
@deftpx {Parent Type} mmec-number
Base type of all the custom exact integer number types defined by this module.
@end deftp


@deftp {Abstract Object Type} mmec-signed-integer
@deftpx {Parent Type} mmec-integer
Base type of all the custom exact signed integer number types defined by this module.
@end deftp


@deftp {Abstract Object Type} mmec-unsigned-integer
@deftpx {Parent Type} mmec-integer
Base type of all the custom exact unsigned integer number types defined by this module.
@end deftp


@deftp {Abstract Object Type} mmec-floating-point
@deftpx {Parent Type} mmec-number
Base type of all the custom floating--point number types defined by this module.
@end deftp


@defun mmec-number-p @var{OBJ}
@defunx mmec-integer-p @var{OBJ}
@defunx mmec-signed-integer-p @var{OBJ}
@defunx mmec-unsigned-integer-p @var{OBJ}
@defunx mmec-floating-point-p @var{OBJ}
Return true if @var{OBJ} is an instance of the specified type; otherwise return false.
@end defun

@c page
@node ctypes typedefs char
@subsection Wrapper for @code{char}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{char, char, signed-integer, sint64, Emacs built--in @code{integer} object representing its @ascii{} code}

@c page
@node ctypes typedefs schar
@subsection Wrapper for @code{signed char}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{schar, signed char, signed-integer, sint64, Emacs built--in @code{integer} object representing its @ascii{} code}

@c page
@node ctypes typedefs uchar
@subsection Wrapper for @code{unsigned char}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{uchar, unsigned char, unsigned-integer, uint64, Emacs built--in @code{integer} object representing its @ascii{} code}

@c page
@node ctypes typedefs wchar
@subsection Wrapper for @code{wchar_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{wchar, wchar_t, unsigned-integer, uint64, Emacs user--pointer object representing its code}

@c page
@node ctypes typedefs sshrt
@subsection Wrapper for @code{signed short int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{sshrt, signed short int, signed-integer, sint64, Emacs built--in @objtype{integer} value}

@c page
@node ctypes typedefs ushrt
@subsection Wrapper for @code{unsigned short int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{ushrt, unsigned short int, unsigned-integer, uint64, Emacs built--in @objtype{integer} value}

@c page
@node ctypes typedefs sint
@subsection Wrapper for @code{signed int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{sint, signed int, signed-integer, sint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs uint
@subsection Wrapper for @code{unsigned int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{uint, unsigned int, unsigned-integer, uint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs slong
@subsection Wrapper for @code{signed long int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{slong, signed long int, signed-integer, sint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs ulong
@subsection Wrapper for @code{unsigned long int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{ulong, unsigned long int, unsigned-integer, uint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs sllong
@subsection Wrapper for @code{signed long long int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{sllong, signed long long int, signed-integer, sint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs ullong
@subsection Wrapper for @code{unsigned long long int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{ullong, unsigned long long int, unsigned-integer, uint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs ssize
@subsection Wrapper for @code{ssize_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{ssize, ssize_t, signed-integer, sint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs usize
@subsection Wrapper for @code{size_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{usize, size_t, unsigned-integer, uint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs sintmax
@subsection Wrapper for @code{intmax_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{sintmax, intmax_t, signed-integer, sint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs uintmax
@subsection Wrapper for @code{uintmax_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{uintmax, uintmax_t, unsigned-integer, uint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs ptrdiff
@subsection Wrapper for @code{ptrdiff_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{ptrdiff, ptrdiff_t, signed-integer, sint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs sint8
@subsection Wrapper for @code{int8_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{sint8, int8_t, signed-integer, sint64, Emacs built--in @objtype{integer} value}

@c page
@node ctypes typedefs uint8
@subsection Wrapper for @code{uint8_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{uint8, uint8_t, unsigned-integer, uint64, Emacs built--in @objtype{integer} value}

@c page
@node ctypes typedefs sint16
@subsection Wrapper for @code{int16_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{sint16, int16_t, signed-integer, sint64, Emacs built--in @objtype{integer} value}

@c page
@node ctypes typedefs uint16
@subsection Wrapper for @code{uint16_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{uint16, uint16_t, unsigned-integer, uint64, Emacs built--in @objtype{integer} value}

@c page
@node ctypes typedefs sint32
@subsection Wrapper for @code{int32_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{sint32, int32_t, signed-integer, sint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs uint32
@subsection Wrapper for @code{uint32_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{uint32, uint32_t, unsigned-integer, uint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs sint64
@subsection Wrapper for @code{int64_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.  The custom
number type @objtype{mmec-sint64} is special because it is used for normalised representation of all
the exact signed integer numbers, both built--in and custom.


@ElispNumberValueTypeDefinition{sint64, int64_t, signed-integer, sint64, Emacs user--pointer object representing its value}
@ElispNumberValueDefaultMethods{sint64, int64_t, signed-integer, sint64, Emacs user--pointer object representing its value}


@deffn {Method} mmec-sint64 (@var{INIT} integer)
Specialised constructor for number values of type @objtype{mmec-sint64}.

This constructor assumes that a value of type @objtype{integer} always fits into the internal
representation of a @objtype{mmec-sint64} value.
@end deffn


@deffn {Method} mmec-sint64 (@var{INIT} float)
Specialised constructor for number values of type @objtype{mmec-sint64}.

This constructor assumes that a value of type @objtype{float} always fits into the internal
representation of a @objtype{mmec-sint64} value.  The floating--point number is first rounded to
integer with the standard C language function @cfunc{round}.
@end deffn


@deffn {Method} mmec-sint64 (@var{INIT} mmec-char)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-schar)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-sshrt)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-sint)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-slong)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-sllong)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-sintmax)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-ssize)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-ptrdiff)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-sint8)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-sint16)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-sint32)
Specialised constructor for number values of type @objtype{mmec-sint64}.

This constructor normalises the internal representation of @var{INIT} to a @code{int64_t} value,
assuming that the internal representation always fits the range of @code{int64_t}.
@end deffn


@deffn {Method} mmec-sint64 (@var{INIT} mmec-number)
Specialised constructor for number values of type @objtype{mmec-sint64}.

This constructor signals that the given initialisation argument is invalid by raising the condition
@code{mmec-error-unsupported-init-type}.
@end deffn

@c ------------------------------------------------------------------------

@ElispNumberValueFitsFunctions{sint64, int64_t, signed-integer, sint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs uint64
@subsection Wrapper for @code{uint64_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.  The custom
number type @objtype{mmec-uint64} is special because it is used for normalised representation of all
the exact unsigned integer numbers, both built--in and custom.


@ElispNumberValueTypeDefinition{uint64, uint64_t, unsigned-integer, uint64, Emacs user--pointer object representing its value}
@ElispNumberValueDefaultMethods{uint64, uint64_t, unsigned-integer, uint64, Emacs user--pointer object representing its value}


@deffn {Method} mmec-uint64 (@var{INIT} integer)
Specialised constructor for number values of type @objtype{mmec-uint64}.

This constructor assumes that a value of type @objtype{integer} always fits into the internal
representation of a @objtype{mmec-uint64} value.  If @var{INIT} is negative: this method raises the
condition @code{mmec-error-value-out-of-range}.
@end deffn


@deffn {Method} mmec-uint64 (@var{INIT} float)
Specialised constructor for number values of type @objtype{mmec-uint64}.

This constructor assumes that a value of type @objtype{float} always fits into the internal
representation of a @objtype{mmec-uint64} value.  The floating--point number is first rounded to
integer with the standard C language function @cfunc{round}.  If @var{INIT} is negative: this method
raises the condition @code{mmec-error-value-out-of-range}.
@end deffn


@deffn {Method} mmec-uint64 (@var{INIT} mmec-uchar)
@deffnx {Method} mmec-uint64 (@var{INIT} mmec-ushrt)
@deffnx {Method} mmec-uint64 (@var{INIT} mmec-uint)
@deffnx {Method} mmec-uint64 (@var{INIT} mmec-ulong)
@deffnx {Method} mmec-uint64 (@var{INIT} mmec-ullong)
@deffnx {Method} mmec-uint64 (@var{INIT} mmec-uintmax)
@deffnx {Method} mmec-uint64 (@var{INIT} mmec-usize)
@deffnx {Method} mmec-uint64 (@var{INIT} mmec-uint8)
@deffnx {Method} mmec-uint64 (@var{INIT} mmec-uint16)
@deffnx {Method} mmec-uint64 (@var{INIT} mmec-uint32)
Specialised constructor for number values of type @objtype{mmec-uint64}.

This constructor normalises the internal representation of @var{INIT} to a @code{uint64_t} value,
assuming that the internal representation always fits the range of @code{uint64_t}.
@end deffn


@deffn {Method} mmec-uint64 (@var{INIT} mmec-number)
Specialised constructor for number values of type @objtype{mmec-uint64}.

This constructor signals that the given initialisation argument is invalid by raising the condition
@code{mmec-error-unsupported-init-type}.
@end deffn

@c ------------------------------------------------------------------------

@ElispNumberValueFitsFunctions{uint64, uint64_t, unsigned-integer, uint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs float
@subsection Wrapper for @code{float}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{float, float, floating-point, ldouble, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs double
@subsection Wrapper for @code{double}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{double, double, floating-point, ldouble, Emacs built--in @objtype{float} value}

@c page
@node ctypes typedefs ldouble
@subsection Wrapper for @code{long double}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.  The custom
number type @objtype{mmec-ldouble} is special because it is used for normalised representation of
all the floating--point numbers, both built--in and custom.


@ElispNumberValueTypeDefinition{ldouble, long double, floating-point, ldouble, Emacs user--pointer object representing its value}
@ElispNumberValueDefaultMethods{ldouble, long double, floating-point, ldouble, Emacs user--pointer object representing its value}


@deffn {Method} mmec-ldouble (@var{INIT} integer)
Specialised constructor for number values of type @objtype{mmec-ldouble}.

This constructor assumes that a value of type @objtype{integer} always fits into the internal
representation of a @objtype{mmec-ldouble} value.  The argument @var{INIT} is first converted to the
Emacs built--in type @objtype{float} with the function @func{float}.
@end deffn


@deffn {Method} mmec-ldouble (@var{INIT} float)
Specialised constructor for number values of type @objtype{mmec-ldouble}.

This constructor assumes that a value of type @objtype{float} always fits into the internal
representation of a @objtype{mmec-ldouble} value.
@end deffn


@deffn {Method} mmec-ldouble (@var{INIT} mmec-float)
@deffnx {Method} mmec-ldouble (@var{INIT} mmec-double)
Specialised constructor for number values of type @objtype{mmec-ldouble}.

This constructor normalises the internal representation of @var{INIT} to a @code{long double} value,
assuming that the internal representation always fits the range of @code{long double}.
@end deffn


@deffn {Method} mmec-ldouble (@var{INIT} mmec-number)
Specialised constructor for number values of type @objtype{mmec-ldouble}.

This constructor signals that the given initialisation argument is invalid by raising the condition
@code{mmec-error-unsupported-init-type}.
@end deffn

@c ------------------------------------------------------------------------

@ElispNumberValueFitsFunctions{ldouble, long double, floating-point, ldouble, Emacs user--pointer object representing its value}

@c page
@node ctypes comparison
@section Comparison operations


To perform a comparison operation among operands of different types, we normalise the operands as
follows:

@itemize
@item
We convert all the signed integers to @objtype{mmec-sint64}.

@item
We convert all the unsigned integers to @objtype{mmec-uint64}.

@item
We convert all the floating--point numbers to @objtype{mmec-ldouble}.

@item
When comparing integers and floating--point numbers we convert all the integer types to
@objtype{mmec-ldouble}.
@end itemize

@c ------------------------------------------------------------------------


@macro mmuxDefunNumericComparisonMethod{OPERATOR, TYPE1, TYPE2}
@deffn {Method} mmec-2\OPERATOR\ ((@vari{op} \TYPE1\) (@varii{op} \TYPE2\))
Return true if @vari{OP} \OPERATOR\ @varii{OP}; otherwise return false.
@end deffn

@end macro


@macro mmuxDefunNumericComparisonFunction{OPERATOR, OPERATIONDESCRIPTION}
@defun mmec\OPERATOR\ @var{OP} &rest @var{ops}
Return true if all the operands are \OPERATIONDESCRIPTION\, left to right; otherwise return false.
The comparison is performed with the generic function @func{mmec-2\OPERATOR\}.
@end defun


@deffn {Generic Function} {mmec-2\OPERATOR\} (@vari{OP} @varii{OP})
Return true if @vari{OP} \OPERATOR\ @varii{OP}; otherwise return false.
@end deffn

@c These are the methods that actually do the operation on built-in numeric objects.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, integer, integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, integer, float}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, float,   integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, float,   float}

@c These are the methods that actually do the operation on custom user-pointer objects.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-sint64, mmec-sint64}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-uint64, mmec-uint64}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-sint64, mmec-uint64}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-uint64, mmec-sint64}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-ldouble, mmec-ldouble}

@c These are the methods that normalise operands among operational types.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-sint64, mmec-ldouble}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-uint64, mmec-ldouble}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-ldouble, mmec-sint64}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-ldouble, mmec-uint64}

@c These are the methods that normalise among integer types.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-signed-integer,   mmec-signed-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-unsigned-integer, mmec-unsigned-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-signed-integer,   mmec-unsigned-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-unsigned-integer, mmec-signed-integer}

@c These are the methods that normalise among floating point types.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-floating-point, mmec-floating-point}

@c These are the methods that normalise mixed numeric types: `mmec-floating-point', `mmec-signed-integer', `mmec-unsigned-intger'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-floating-point,   mmec-signed-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-signed-integer,   mmec-floating-point}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-floating-point,   mmec-unsigned-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-unsigned-integer, mmec-floating-point}

@c These are the methods that normalise mixed numeric types: `integer' and `mmec-floating-point'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, integer, mmec-floating-point}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-floating-point, integer}

@c These are the methods that normalise mixed numeric types: `integer' and `mmec-signed-integer'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, integer, mmec-signed-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-signed-integer, integer}

@c These are the methods that normalise mixed numeric types: `integer' and `mmec-unsigned-integer'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, integer, mmec-unsigned-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-unsigned-integer, integer}

@c These are the methods that normalise mixed numeric types: `float' and `mmec-floating-point'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, float, mmec-floating-point}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-floating-point, float}

@c These are the methods that normalise mixed numeric types: `float' and `mmec-signed-integer'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, float, mmec-signed-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-signed-integer, float}

@c These are the methods that normalise mixed numeric types: `float' and `mmec-unsigned-integer'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, float, mmec-unsigned-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-unsigned-integer, float}
@end macro

@c ------------------------------------------------------------------------

@menu
* ctypes comparison eq::        Equality functions.
* ctypes comparison neq::       Non-equality functions.
* ctypes comparison less::      Less than functions.
* ctypes comparison greater::   Greater than functions.
* ctypes comparison leq::       Less than or equal to functions.
* ctypes comparison geq::       Greater than or equal to functions.
@end menu

@c page
@node ctypes comparison eq
@subsection Equality functions


@mmuxDefunNumericComparisonFunction{=, one equal to the other}

@c page
@node ctypes comparison neq
@subsection Non--equality functions


@mmuxDefunNumericComparisonFunction{/=, one not equal to the other}

@c page
@node ctypes comparison less
@subsection Less than functions


@mmuxDefunNumericComparisonFunction{<, one less than the other}

@c page
@node ctypes comparison greater
@subsection Greater than functions


@mmuxDefunNumericComparisonFunction{>, one greater than the other}

@c page
@node ctypes comparison leq
@subsection Less than or equal to functions


@mmuxDefunNumericComparisonFunction{<=, one less than or equal to the other}

@c page
@node ctypes comparison geq
@subsection Greater than or equal to functions


@mmuxDefunNumericComparisonFunction{>=, one greater than or equal to the other}

@c page
@node bytevectors
@chapter Bytevector objects


@menu
* bytevectors typedefs::        Type definition.
* bytevectors pred::            Type predicates.
* bytevectors getters::         Bytevector getters.
* bytevectors setters::         Bytevector setters.
@end menu

@c page
@node bytevectors typedefs
@section Type definition


@deftp {Object Type} mmec-bytevector
Base type of bytevector objects: it can represent binary data with a C language array.  Objects of
this type are correctly garbage collected.  It has the following fields:

@table @code
@item number-of-slots
Non--negative exact integer representing the number of slots in a bytevector.

@item slot-size
Non--negative exact integer representing the size of a slot measured in bytes.

@item number-of-allocated-bytes
Non--negative exact integer representing the number of bytes allocated in the data area.

@item obj
User--pointer object.
@end table
@end deftp


@deftp {Object Type} mmec-integer-bytevector
@deftpx {Parent Type} mmec-bytevector
Base type of bytevector objects holding C language integers in their slots.  Objects of this type
are correctly garbage collected.  In addition to the slots of @objtype{mmec-bytevector}, it has the
following fields:

@table @code
@item signed
Boolean, true if the data in each slot is to be interpreted as a signed integer; false if it has to
be interpreted as an unsigned integer.
@end table
@end deftp


@deftp {Object Type} mmec-float-bytevector
@deftpx {Parent Type} mmec-bytevector
Base type of bytevector objects holding C language floating--point values in their slots.  Objects
of this type are correctly garbage collected.
@end deftp

@c ------------------------------------------------------------------------

@deftp {Object Type} mmec-bytevector-u8
@deftpx {Parent Type} mmec-integer-bytevector
Type of bytevector objects holding C language integer of type @code{uint8_t} in their slots.
Objects of this type are correctly garbage collected.
@end deftp


@deftp {Object Type} mmec-bytevector-s8
@deftpx {Parent Type} mmec-integer-bytevector
Type of bytevector objects holding C language integer of type @code{int8_t} in their slots.  Objects
of this type are correctly garbage collected.
@end deftp

@c ------------------------------------------------------------------------

@deftp {Object Type} mmec-bytevector-u16
@deftpx {Parent Type} mmec-integer-bytevector
Type of bytevector objects holding C language integer of type @code{uint16_t} in their slots.
Objects of this type are correctly garbage collected.
@end deftp


@deftp {Object Type} mmec-bytevector-s16
@deftpx {Parent Type} mmec-integer-bytevector
Type of bytevector objects holding C language integer of type @code{int16_t} in their slots.
Objects of this type are correctly garbage collected.
@end deftp

@c ------------------------------------------------------------------------

@deftp {Object Type} mmec-bytevector-u32
@deftpx {Parent Type} mmec-integer-bytevector
Type of bytevector objects holding C language integer of type @code{uint32_t} in their slots.
Objects of this type are correctly garbage collected.
@end deftp


@deftp {Object Type} mmec-bytevector-s32
@deftpx {Parent Type} mmec-integer-bytevector
Type of bytevector objects holding C language integer of type @code{int32_t} in their slots.
Objects of this type are correctly garbage collected.
@end deftp

@c ------------------------------------------------------------------------

@deftp {Object Type} mmec-bytevector-u64
@deftpx {Parent Type} mmec-integer-bytevector
Type of bytevector objects holding C language integer of type @code{uint64_t} in their slots.
Objects of this type are correctly garbage collected.
@end deftp


@deftp {Object Type} mmec-bytevector-s64
@deftpx {Parent Type} mmec-integer-bytevector
Type of bytevector objects holding C language integer of type @code{int64_t} in their slots.
Objects of this type are correctly garbage collected.
@end deftp

@c ------------------------------------------------------------------------

@deftp {Object Type} mmec-bytevector-float
@deftpx {Parent Type} mmec-float-bytevector
Type of bytevector objects holding C language values of type @code{float} in their slots.  Objects
of this type are correctly garbage collected.
@end deftp


@deftp {Object Type} mmec-bytevector-double
@deftpx {Parent Type} mmec-float-bytevector
Type of bytevector objects holding C language values of type @code{double} in their slots.  Objects
of this type are correctly garbage collected.
@end deftp


@deftp {Object Type} mmec-bytevector-ldouble
@deftpx {Parent Type} mmec-float-bytevector
Type of bytevector objects holding C language values of type @code{long double} in their slots.
Objects of this type are correctly garbage collected.
@end deftp

@c page
@node bytevectors pred
@section Type predicates


@defun mmec-bytevector-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{mmec-bytevector}; otherwise return false.
@end defun


@defun mmec-integer-bytevector-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{mmec-integer-bytevector}; otherwise return false.
@end defun


@defun mmec-float-bytevector-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{mmec-float-bytevector}; otherwise return false.
@end defun

@c ------------------------------------------------------------------------

@defun mmec-bytevector-u8-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{mmec-bytevector-u8}; otherwise return false.
@end defun


@defun mmec-bytevector-s8-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{mmec-bytevector-s8}; otherwise return false.
@end defun

@c ------------------------------------------------------------------------

@defun mmec-bytevector-u16-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{mmec-bytevector-u16}; otherwise return false.
@end defun


@defun mmec-bytevector-s16-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{mmec-bytevector-s16}; otherwise return false.
@end defun

@c ------------------------------------------------------------------------

@defun mmec-bytevector-u32-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{mmec-bytevector-u32}; otherwise return false.
@end defun


@defun mmec-bytevector-s32-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{mmec-bytevector-s32}; otherwise return false.
@end defun

@c ------------------------------------------------------------------------

@defun mmec-bytevector-u64-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{mmec-bytevector-u64}; otherwise return false.
@end defun


@defun mmec-bytevector-s64-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{mmec-bytevector-s64}; otherwise return false.
@end defun

@c ------------------------------------------------------------------------

@defun mmec-bytevector-float-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{mmec-bytevector-float}; otherwise return false.
@end defun


@defun mmec-bytevector-double-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{mmec-bytevector-double}; otherwise return false.
@end defun


@defun mmec-bytevector-ldouble-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{mmec-bytevector-ldouble}; otherwise return
false.
@end defun

@c page
@node bytevectors getters
@section Bytevector getters


@deffn {Generic Function} mmec-bytevector-ref (@var{BV} @var{IDX})
Extract the value at index @var{IDX} from the bytevector @var{BV}.
@end deffn


@deffn {Method} mmec-bytevector-ref ((@var{BV} mmec-bytevector-u8) (@var{IDX} mmec-usize))
Extract an @code{uint8_t} value from a bytevector and wrap it into a @objtype{mmec-uint8} object.
@end deffn


@deffn {Method} mmec-bytevector-ref ((@var{BV} mmec-bytevector-s8) (@var{IDX} mmec-usize))
Extract an @code{int8_t} value from a bytevector and wrap it into a @objtype{mmec-sint8} object.
@end deffn


@deffn {Method} mmec-bytevector-ref ((@var{BV} mmec-bytevector-u16) (@var{IDX} mmec-usize))
Extract an @code{uint16_t} value from a bytevector and wrap it into a @objtype{mmec-uin1t16} object.
@end deffn


@deffn {Method} mmec-bytevector-ref ((@var{BV} mmec-bytevector-s16) (@var{IDX} mmec-usize))
Extract an @code{int16_t} value from a bytevector and wrap it into a @objtype{mmec-sint16} object.
@end deffn


@deffn {Method} mmec-bytevector-ref ((@var{BV} mmec-bytevector-u32) (@var{IDX} mmec-usize))
Extract an @code{uint32_t} value from a bytevector and wrap it into a @objtype{mmec-uint32} object.
@end deffn


@deffn {Method} mmec-bytevector-ref ((@var{BV} mmec-bytevector-s32) (@var{IDX} mmec-usize))
Extract an @code{int32_t} value from a bytevector and wrap it into a @objtype{mmec-sint32} object.
@end deffn


@deffn {Method} mmec-bytevector-ref ((@var{BV} mmec-bytevector-u64) (@var{IDX} mmec-usize))
Extract an @code{uint64_t} value from a bytevector and wrap it into a @objtype{mmec-uint64} object.
@end deffn


@deffn {Method} mmec-bytevector-ref ((@var{BV} mmec-bytevector-s64) (@var{IDX} mmec-usize))
Extract an @code{int64_t} value from a bytevector and wrap it into a @objtype{mmec-sint64} object.
@end deffn

@c page
@node bytevectors setters
@section Bytevector setters


@deffn {Generic Function} mmec-bytevector-set! (bv idx val)
Store the value @var{VAL} into the bytevector @var{BV} at index @var{idx}.
@end deffn


@deffn {Method} mmec-bytevector-set! ((@var{BV} mmec-bytevector-u8) (@var{IDX} mmec-usize) (@var{VAL} mmec-uint8))
Store the value @var{VAL} of type @code{uint8_t} into the bytevector @var{BV} at index @var{IDX}.
@end deffn


@deffn {Method} mmec-bytevector-set! ((@var{BV} mmec-bytevector-s8) (@var{IDX} mmec-usize) (@var{VAL} mmec-sint8))
Store the value @var{VAL} of type @code{int8_t} into the bytevector @var{BV} at index @var{IDX}.
@end deffn


@deffn {Method} mmec-bytevector-set! ((@var{BV} mmec-bytevector-u16) (@var{IDX} mmec-usize) (@var{VAL} mmec-uint16))
Store the value @var{VAL} of type @code{uint16_t} into the bytevector @var{BV} at index @var{IDX}.
@end deffn


@deffn {Method} mmec-bytevector-set! ((@var{BV} mmec-bytevector-s16) (@var{IDX} mmec-usize) (@var{VAL} mmec-sint16))
Store the value @var{VAL} of type @code{int16_t} into the bytevector @var{BV} at index @var{IDX}.
@end deffn


@deffn {Method} mmec-bytevector-set! ((@var{BV} mmec-bytevector-u32) (@var{IDX} mmec-usize) (@var{VAL} mmec-uint32))
Store the value @var{VAL} of type @code{uint32_t} into the bytevector @var{BV} at index @var{IDX}.
@end deffn


@deffn {Method} mmec-bytevector-set! ((@var{BV} mmec-bytevector-s32) (@var{IDX} mmec-usize) (@var{VAL} mmec-sint32))
Store the value @var{VAL} of type @code{int32_t} into the bytevector @var{BV} at index @var{IDX}.
@end deffn


@deffn {Method} mmec-bytevector-set! ((@var{BV} mmec-bytevector-u64) (@var{IDX} mmec-usize) (@var{VAL} mmec-uint64))
Store the value @var{VAL} of type @code{uint64_t} into the bytevector @var{BV} at index @var{IDX}.
@end deffn


@deffn {Method} mmec-bytevector-set! ((@var{BV} mmec-bytevector-s64) (@var{IDX} mmec-usize) (@var{VAL} mmec-sint64))
Store the value @var{VAL} of type @code{int64_t} into the bytevector @var{BV} at index @var{IDX}.
@end deffn

@c page
@node errors
@chapter How errors are signalled


Occasionally the functions in @value{PACKAGE} signal an error; the following error symbols are
defined.


@defvr {Error Symbol} mmec-error
The base type of all the error symbols.
@end defvr


@menu
* errors constructor::          Constructor errors.
* errors range::                Range errors.
* errors operations::           Operation errors.
@end menu

@c page
@node errors constructor
@section Constructor errors


@defvr {Error Symbol} mmec-error-constructor
@defvrx {Parent Error Symbol} mmec-error
An error occurred while constructing an object.
@end defvr


@defvr {Error Symbol} mmec-error-no-memory
@defvrx {Parent Error Symbol} mmec-error-constructor
Used to signal that there was not enough memory to allocate an object.
@end defvr


@defvr {Error Symbol} mmec-error-instantiating-abstract-type
@defvrx {Parent Error Symbol} mmec-error-constructor
An attempt was performed to instantiate an abstract data type.
@end defvr


@defvr {Error Symbol} mmec-error-unsupported-init-type
@defvrx {Parent Error Symbol} mmec-error-constructor
An argument given to an object constructor has an unsupported type.
@end defvr

@c page
@node errors range
@section Range errors


@defvr {Error Symbol} mmec-error-value-out-of-range
@defvrx {Parent Error Symbol} mmec-error
A numeric object is out of range.
@end defvr


@defvr {Error Symbol} mmec-error-index-out-of-range
@defvrx {Parent Error Symbol} mmec-error-value-out-of-range
Used to signal an attempt to access the internal represenation of an object with an index out of
range.
@end defvr


@defvr {Error Symbol} mmec-error-bytevector-index-out-of-range
@defvrx {Parent Error Symbol} mmec-error-index-out-of-range
Attempt to access the internal represenation of a bytevector object with an index out of range.
@end defvr

@c page
@node errors operations
@section Operation errors


@defvr {Error Symbol} mmec-error-signed/unsigned-integer-comparison
@defvrx {Parent Error Symbol} mmec-error
Cannot compare a signed integer with an unsigned integer.
@end defvr

@c page
@node capi
@chapter C language programming interface


@menu
* capi version::                Version informations.
* capi typedefs::               General type definitions.
* capi errors::                 Signalling errors.
* capi modules::                Modules related definitions.
* capi objects::                Handling Emacs Lisp objects.
@end menu

@c page
@node capi version
@section Version informations


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} mmec_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int mmec_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int mmec_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int mmec_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node capi typedefs
@section General type definitions


@menu
* capi typedefs clang::         C language type definitions.
@end menu

@c page
@node capi typedefs clang
@subsection C language type definitions


The following type definitions are useful when defining macros: every type name has the C language
specification in a single word, so we can build macro expansions with:

@example
#undef  THE_TYPE
#define THE_TYPE(STEM)          mmec_clang_ ## STEM ## _t

THE_TYPE(char)
THE_TYPE(sshrt)
THE_TYPE(ullong)
@end example


@deftp {Type definition} mmec_clang_char_t
An alias for the C language type @code{char}.
@end deftp


@deftp {Type definition} mmec_clang_schar_t
An alias for the C language type @code{signed char}.
@end deftp


@deftp {Type definition} mmec_clang_uchar_t
An alias for the C language type @code{unsigned char}.
@end deftp


@deftp {Type definition} mmec_clang_wchar_t
An alias for the C language type @code{wchar_t}.
@end deftp


@deftp {Type definition} mmec_clang_sshrt_t
An alias for the C language type @code{signed   short int}.
@end deftp


@deftp {Type definition} mmec_clang_ushrt_t
An alias for the C language type @code{unsigned short int}.
@end deftp


@deftp {Type definition} mmec_clang_sint_t
An alias for the C language type @code{signed   int}.
@end deftp


@deftp {Type definition} mmec_clang_uint_t
An alias for the C language type @code{unsigned int}.
@end deftp


@deftp {Type definition} mmec_clang_slong_t
An alias for the C language type @code{signed   long int}.
@end deftp


@deftp {Type definition} mmec_clang_ulong_t
An alias for the C language type @code{unsigned long int}.
@end deftp


@deftp {Type definition} mmec_clang_sllong_t
An alias for the C language type @code{signed   long long int}.
@end deftp


@deftp {Type definition} mmec_clang_ullong_t
An alias for the C language type @code{unsigned long long int}.
@end deftp


@deftp {Type definition} mmec_clang_ssize_t
An alias for the C language type @code{ssize_t}.
@end deftp


@deftp {Type definition} mmec_clang_usize_t
An alias for the C language type @code{size_t}.
@end deftp


@deftp {Type definition} mmec_clang_sintmax_t
An alias for the C language type @code{intmax_t}.
@end deftp


@deftp {Type definition} mmec_clang_uintmax_t
An alias for the C language type @code{uintmax_t}.
@end deftp


@deftp {Type definition} mmec_clang_ptrdiff_t
An alias for the C language type @code{ptrdiff_t}.
@end deftp


@deftp {Type definition} mmec_clang_sint8_t
An alias for the C language type @code{int8_t}.
@end deftp


@deftp {Type definition} mmec_clang_uint8_t
An alias for the C language type @code{uint8_t}.
@end deftp


@deftp {Type definition} mmec_clang_sint16_t
An alias for the C language type @code{int16_t}.
@end deftp


@deftp {Type definition} mmec_clang_uint16_t
An alias for the C language type @code{uint16_t}.
@end deftp


@deftp {Type definition} mmec_clang_sint32_t
An alias for the C language type @code{int32_t}.
@end deftp


@deftp {Type definition} mmec_clang_uint32_t
An alias for the C language type @code{uint32_t}.
@end deftp


@deftp {Type definition} mmec_clang_sint64_t
An alias for the C language type @code{int64_t}.
@end deftp


@deftp {Type definition} mmec_clang_uint64_t
An alias for the C language type @code{uint64_t}.
@end deftp


@deftp {Type definition} mmec_clang_float_t
An alias for the C language type @code{float}.
@end deftp


@deftp {Type definition} mmec_clang_double_t
An alias for the C language type @code{double}.
@end deftp


@deftp {Type definition} mmec_clang_ldouble_t
An alias for the C language type @code{long double}.
@end deftp

@c page
@node capi errors
@section Signalling errors


@menu
* capi errors typedefs::        Error signalling type definitions.
* capi errors macros::          Error signalling preprocessor macros.
* capi errors base::            Signalling base errors.
* capi errors constructor::     Signalling constructor errors.
* capi errors range::           Signalling range errors.
* capi errors operations::      Signalling operation errors.
@end menu

@c page
@node capi errors typedefs
@subsection Error signalling type definitions


@deftypefn {Function Protoype} emacs_value mmec_error_signaller_fun_t (emacs_env * @var{env})
Prototype of functions signalling an error.
@end deftypefn

@c page
@node capi errors macros
@subsection Error signalling preprocessor macros


@defmac MMEC_DEFINE_ERROR_SIGNALLER (@var{PREFIX}, @var{NAME}, @var{SYMBOL}, @var{MESSAGE})
Expand into the definition of an error signalling function.  The expansion is:

@example
emacs_value
PREFIX ## _error_ ## NAME (emacs_env * env)
@{
  char const   *errmsg = MESSAGE;
  emacs_value  Serrmsg = \
    mmec_new_emacs_string(env, errmsg, strlen(errmsg));

  env->non_local_exit_signal(env,
    env->intern(env, SYMBOL), Serrmsg);
  return env->intern(env, "nil");
@}
@end example

We could define an error signaller function with prototype:

@example
mmec_error_signaller_fun_t mmec_error_memory_allocation;
@end example

@noindent
as:

@example
MMEC_DEFINE_ERROR_SIGNALLER(mmec, memory_alloction,
  "mmec-error-no-memory",
  "Not enough memory available to allocate an object.")
@end example
@end defmac

@c page
@node capi errors base
@subsection Signalling base errors


@deftypefun emacs_value mmec_error_base (emacs_env * @var{env})
Signal an error with error symbol @code{mmec-error} then return @nil{}.
@end deftypefun

@c page
@node capi errors constructor
@subsection Signalling constructor errors


@deftypefun emacs_value mmec_error_constructor (emacs_env * @var{env})
Signal an error with symbol @code{mmec-error-constructor} then return @nil{}.
@end deftypefun


@deftypefun emacs_value mmec_error_memory_allocation (emacs_env * @var{env})
Signal an error with symbol @code{mmec-error-no-memory} then return @nil{}.
@end deftypefun


@deftypefun emacs_value mmec_error_instantiating_abstract_type (emacs_env * @var{env})
Signal an error with symbol @code{mmec-error-instantiating-abstract-type} then return @nil{}.
@end deftypefun


@deftypefun emacs_value mmec_error_unsupported_init_type (emacs_env * @var{env})
Signal an error with symbol @code{mmec-error-unsupported-init-type} then return @nil{}.
@end deftypefun

@c page
@node capi errors range
@subsection Signalling range errors


@deftypefun emacs_value mmec_error_value_out_of_range (emacs_env * @var{env})
Signal an error with symbol @code{mmec-error-value-out-of-range} then return @nil{}.
@end deftypefun


@deftypefun emacs_value mmec_error_index_out_of_range (emacs_env * @var{env})
Signal an error with symbol @code{mmec-error-index-out-of-range} then return @nil{}.
@end deftypefun


@deftypefun emacs_value mmec_error_bytevector_index_out_of_range (emacs_env * @var{env})
Signal an error with symbol @code{mmec-error-bytevector-index-out-of-range} then return @nil{}.
@end deftypefun

@c page
@node capi errors operations
@subsection Signalling operation errors


@deftypefun emacs_value mmec_error_signed_unsigned_integer_comparison (emacs_env * @var{env})
Signal an error with symbol @code{mmec-error-signed/unsigned-integer-comparison} then return @nil{}.
@end deftypefun

@c page
@node capi modules
@section Modules related definitions


Here is an example of how we can define Emacs Lisp functions at the C language level using the
facilities of @value{PACKAGE}:

@example
static emacs_value
Fspiffy_function (emacs_env *env, ptrdiff_t nargs,
                  emacs_value args[], void * data)
@{
  assert(0 == nargs);
  return mmec_new_elisp_nil(env);
@}

#define NUMBER_OF_MODULE_FUNCTIONS      1
static mmec_module_function_t const \
   module_functions_table[NUMBER_OF_MODULE_FUNCTIONS] = @{
  @{
    .name               = "spiffy-function",
    .implementation     = Fspiffy_function,
    .min_arity          = 0,
    .max_arity          = 0,
    .documentation      = "Do something spiffy."
  @}
@}

void
init_spiffy_module (emacs_env * env)
@{
  mmec_define_elisp_functions_from_table(env,
    module_functions_table, NUMBER_OF_MODULE_FUNCTIONS, 0);
@}
@end example


@deftypefn {Function Prototype} emacs_value mmec_elisp_function_implementation_t (emacs_env * @var{env}, ptrdiff_t @var{nargs}, emacs_value @var{args}[], void * @var{data})
Prototype of Emacs Lisp functions defined at the C language level.
@end deftypefn


@deftp {Struct Typedef} mmec_module_function_t
Structure type representing an Emacs Lisp function definition at the C language level.  Instances of
this type area meant to be defined in a an array and used to initialise a module.

@table @code
@item char const * name
Pointer to an @asciiz{} representing the name of the Emacs Lisp function.

@item mmec_elisp_function_implementation_t * implementation
Pointer to the C language function implementing the Emacs Lisp function.

@item ptrdiff_t min_arity
Minimum number of arguments accepted by the Emacs Lisp function.  It is the minimum number of items
in the array @var{args} of the functions with type @objtype{mmec_elisp_function_implementation_t}.

@item ptrdiff_t max_arity
Maximum number of arguments accepted by the Emacs Lisp function.  It is the maximum number of items
in the array @var{args} of the functions with type @objtype{mmec_elisp_function_implementation_t}.

@item char const * documentation
Pointer to an @asciiz{} representing the documentation of the Emacs Lisp function.
@end table
@end deftp


@deftypefun void mmec_define_elisp_functions_from_table (emacs_env * @var{env}, mmec_module_function_t const * @var{module_functions}, int @var{number_of_module_functions}, int @var{verbose})
Define a number of Emacs Lisp functions at the C language level.

The argument @var{env} must be the environment in which the functions will be defined.

The argument @var{module_functions} must be a pointer to an array of Emacs Lisp function
definitions.

The argument @var{number_of_module_functions} must be the number of items in the array referenced by
@var{module_functions}.

If the argument @var{verbose} is true: for every defined function, a string representing the
function name is printed to @code{stderr}, terminated by a newline; otherwise nothing is printed.
@end deftypefun

@c page
@node capi objects
@section Handling Emacs Lisp objects


@menu
* capi objects elisp::          Handling Emacs built-in values.
* capi objects usrptr::         Defining user-pointer objects.
* capi objects clang::          Wrappers for C language values.
@end menu

@c page
@node capi objects elisp
@subsection Handling Emacs built--in values


@menu
* capi objects elisp getters::  Retrieving values from Emacs built-in values.
* capi objects elisp makers::   Making new Emacs built-in values.
@end menu

@c page
@node capi objects elisp getters
@subsubsection Retrieving values from Emacs built--in values


@deftypefun {void *} mmec_get_usrptr_object_from_emacs_value (emacs_env * @var{env}, emacs_value @var{arg})
Given an Emacs Lisp value @var{arg} in the context of the environment @var{env}: get from it a
pointer to a user--pointer object; return the pointer.  The returned value is the internal
representation of @var{arg}, so if we mutate it we will mutate the value @var{arg} itself.

If @var{arg} is not a user--pointer object: the @code{wrong-type-argument} error condition is
raised.
@end deftypefun


@deftypefun intmax_t mmec_extract_elisp_integer_from_emacs_value (emacs_env * @var{env}, emacs_value @var{arg})
Given an Emacs Lisp value @var{arg} in the context of the environment @var{env}: extract from it an
exact integer number; return the number.  The returned value is independent from the internal
representation of @var{arg}.

If @var{arg} is not an exact integer value: the @code{wrong-type-argument} error condition is
raised.
@end deftypefun


@deftypefun double mmec_extract_elisp_float_from_emacs_value (emacs_env * @var{env}, emacs_value @var{arg})
Given an Emacs Lisp value @var{arg} in the context of the environment @var{env}: extract from it a
double--precision floating point number; return the number.  The returned value is independent from
the internal representation of @var{arg}.

If @var{arg} is not an exact integer value: the @code{wrong-type-argument} error condition is
raised.
@end deftypefun

@c page
@node capi objects elisp makers
@subsubsection Making new Emacs built--in values


@deftypefun emacs_value mmec_new_emacs_value_from_usrptr_object (emacs_env * @var{env}, mmec_usrptr_object_finalizer_t @var{finalizer}, void * @var{ptr})
@anchor{mmec_new_emacs_value_from_usrptr_object}
Build and return a new Emacs built--in value from the raw pointer of a user--pointer object
@var{ptr} in the context of the environment @var{env}.  The argument @var{finalizer} must be a
pointer to the user--pointer object destructor.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_nil (emacs_env * @var{env})
Build and return an Emacs built--in value representing the interned symbol @code{nil}, in the
context of the environment @var{env}.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_true (emacs_env * @var{env})
Build and return an Emacs built--in value representing the interned symbol @code{t}, in the context
of the environment @var{env}.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_boolean (emacs_env * @var{env}, int @var{val})
Build and return an Emacs built--in value representing either the interned symbol @code{nil} (if
@var{val} is zero) or the interned symbol @code{t} (if @var{val} is non--zero), in the context of
the environment @var{env}.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_integer (emacs_env * @var{env}, intmax_t @var{val})
Build and return an Emacs built--in value representing the exact integer @var{val}, in the context
of the environment @var{env}.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_float (emacs_env * @var{env}, double @var{val})
Build and return an Emacs built--in value representing the double--precision floating point number
@var{val}, in the context of the environment @var{env}.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_string (emacs_env * @var{env}, char const * @var{ptr}, size_t @var{len})
Build and return an Emacs built--in value representing the @ascii{} string referenced by @var{ptr},
of length @var{len}, in the context of the environment @var{env}.  The C language string is
duplicated in the internal representation of the returned value.
@end deftypefun

@c page
@node capi objects usrptr
@subsection Defining user--pointer objects


@deftypefn {Function Prototype} void mmec_usrptr_object_finalizer_func_t (void * @var{ptr})
Prototype of C language functions usable as user--pointer object destructors.
@end deftypefn


@deftp {Pointer Typedef} mmec_usrptr_object_finalizer_t
Type of pointers to C language functions usable as user--pointer object destructors.  We can use
values of this type as arguments in calls to @cfunc{mmec_new_emacs_value_from_usrptr_object},
@ref{mmec_new_emacs_value_from_usrptr_object}.
@end deftp

@c page
@node capi objects clang
@subsection Wrappers for C language values


@value{PACKAGE} defines a custom value type for every standard C language type we might need when
interfacing with a foreign C language library.  At the Emacs lisp level: these values are
represented by instances of a structure type defined with @func{cl-defstruct}, every structure holds
an Emacs Lisp value as internal representation:

@itemize
@item
Exact integer values that fit into an Emacs built--in @objtype{integer} value have @objtype{integer}
values as internal representation.

@item
Exact integer values that do not fit into an Emacs built--in @objtype{integer} value have a
user--pointer object value as internal representation.

@item
Floating--point values of type @code{double} have Emacs built--in @objtype{float} values as internal
representation.

@item
Floating--point values of type @code{float} and @code{long double} have a user--pointer object value
as internal representation.

@end itemize

At the C language level:

@itemize
@item
Exact integer values that fit into an Emacs built--in @objtype{integer} value have @code{intmax_t}
values as internal representation and we can cast such values to the specific C language type.

@item
Exact integer values that do not fit into an Emacs built--in @objtype{integer} value have a C
language structure as internal representation, with memory dynamically allocated.

@item
Floating--point values of type @code{double} have @code{double} values as internal representation.

@item
Floating--point values of type @code{float} and @code{long double} have a C language structure as
internal representation, with memory dynamically allocated.
@end itemize

@c ------------------------------------------------------------------------

@macro DocumentNumberValueWithIntegerRep{STEM, CTYPE}
@node capi objects clang \STEM\
@subsubsection Wrapper of @code{\CTYPE\}


@deftp {Type Definition} mmec_intrep_\STEM\_t
Type of internal representation for objects wrapping a C language value of type @code{\CTYPE\}.  It
is an alias for @code{intmax_t}.
@end deftp

@subsubheading Extractors

@deftypefun mmec_intrep_\STEM\_t mmec_extract_intrep_\STEM\_from_emacs_value (emacs_env * @var{ENV}, emacs_value @var{ARG})
Given the Emacs value @var{ARG}, in the context of the environment @var{ENV}: extract its internal
representation wrapping the C language value; return the representation itself.  The returned value
is independent from @var{ARG}.

If @var{ARG} is not an Emacs built--in value of type @objtype{integer}: the
@code{wrong-type-argument} error condition is raised.
@end deftypefun


@deftypefun mmec_clang_\STEM\_t mmec_extract_clang_\STEM\_from_emacs_value (emacs_env * @var{ENV}, emacs_value @var{ARG})
Given the Emacs value @var{ARG}, in the context of the environment @var{ENV}: extract from its
representation the raw C language value; return the raw value itself.  The returned value is
independent from @var{ARG}.

If @var{ARG} is not an Emacs built--in value of type @objtype{integer}: the
@code{wrong-type-argument} error condition is raised.
@end deftypefun


@deftypefun mmec_clang_\STEM\_t mmec_extract_clang_\STEM\_from_intrep_\STEM\ (mmec_intrep_\STEM\_t @var{IREP})
Given the internal representation of a wrapper for the C language type @code{\CTYPE\}, extract and
return its value as raw C language value.  The returned value is independent from @var{IREP}.
@end deftypefun

@subsubheading Constructors

@deftypefun mmec_intrep_\STEM\_t mmec_new_intrep_\STEM\_from_clang_\STEM\ (mmec_clang_\STEM\_t @var{VAL})
Given the raw C language value @var{VAL} wrap it into its internal representation and return the
result.  The returned value is independent from @var{VAL}.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_from_intrep_\STEM\ (emacs_env * @var{ENV}, mmec_intrep_\STEM\_t @var{IREP})
Given the internal representation @var{IREP} of a C language value: build and return a new Emacs
value, in the context of the environment @var{ENV}, representing the C language value.  The returned
object is independent from @var{IREP}.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_from_clang_\STEM\ (emacs_env * @var{ENV}, mmec_clang_\STEM\_t @var{VAL})
Given a raw C language value @var{VAL}: build and return a new Emacs value, in the context of the
environment @var{ENV}, representing the value.  The returned object is independent from @var{VAL}.
@end deftypefun
@end macro

@c ------------------------------------------------------------------------

@macro DocumentNumberValueWithFloatRep{STEM, CTYPE}
@node capi objects clang \STEM\
@subsubsection Wrapper of @code{\CTYPE\}


@deftp {Type Definition} mmec_intrep_\STEM\_t
Type of internal representation for objects wrapping a C language value of type @code{\CTYPE\}.  It
is an alias for @code{double}.
@end deftp

@subsubheading Extractors

@deftypefun mmec_intrep_\STEM\_t mmec_extract_intrep_\STEM\_from_emacs_value (emacs_env * @var{ENV}, emacs_value @var{ARG})
Given the Emacs value @var{ARG}, in the context of the environment @var{ENV}: extract its internal
representation wrapping the C language value; return the representation itself.  The returned value
is independent from @var{ARG}.

If @var{ARG} is not an Emacs built--in value of type @objtype{float}: the @code{wrong-type-argument}
error condition is raised.
@end deftypefun


@deftypefun mmec_clang_\STEM\_t mmec_extract_clang_\STEM\_from_emacs_value (emacs_env * @var{ENV}, emacs_value @var{ARG})
Given the Emacs value @var{ARG}, in the context of the environment @var{ENV}: extract from its
internal representation the raw C language value; return the raw value itself.  The returned value
is independent from the Emacs value @var{ARG}.

If @var{ARG} is not an Emacs built--in value of type @objtype{float}: the @code{wrong-type-argument}
error condition is raised.
@end deftypefun


@deftypefun mmec_clang_\STEM\_t mmec_extract_clang_\STEM\_from_intrep_\STEM\ (mmec_intrep_\STEM\_t @var{IREP})
Given the internal representation of a wrapper for the C language type @code{\CTYPE\}, extract and
return its value as raw C language value.
@end deftypefun

@subsubheading Constructors

@deftypefun mmec_intrep_\STEM\_t mmec_new_intrep_\STEM\_from_clang_\STEM\ (mmec_clang_\STEM\_t @var{VAL})
Given the raw C language value @var{VAL} wrap it into its internal representation and return the
result.  The returned value is independent from @var{VAL}.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_from_intrep_\STEM\ (emacs_env * @var{ENV}, mmec_intrep_\STEM\_t @var{VAL})
Given the internal representation @var{VAL} of a C language value: build and return a new Emacs
value, in the context of the environment @var{ENV}, representing the C language value itself.  The
returned object is independent from @var{VAL}.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_from_clang_\STEM\ (emacs_env * @var{ENV}, mmec_clang_\STEM\_t @var{VAL})
Given a raw C language value: build and return a new Emacs value, in the context of the environment
@var{ENV}, representing the raw value itself.  The returned object is independent from @var{VAL}.
@end deftypefun
@end macro

@c ------------------------------------------------------------------------

@macro DocumentNumberValueWithUsrptrRep{STEM, CTYPE}
@node capi objects clang \STEM\
@subsubsection Wrapper of @code{\CTYPE\}

@deftp {Struct Pointer} mmec_intrep_\STEM\_t
Type of internal representation for objects wrapping a C language value of type @code{\CTYPE\} and
using a user--pointer object as internal representation.
@end deftp

@subsubheading Extractors

@deftypefun mmec_intrep_\STEM\_t mmec_get_intrep_\STEM\_from_emacs_value (emacs_env * @var{ENV}, emacs_value @var{ARG})
Given the Emacs value @var{ARG}, in the context of the environment @var{ENV}: retrieve its internal
representation wrapping the C language value; return the representation.  The returned value is
still dependent from @var{ARG}: if we mutate it, we will mutate the original Emacs value.

If @var{ARG} is not an Emacs user--pointer object: the @code{wrong-type-argument} error condition is
raised.  At the C language level: there is no way to validate @var{ARG} as having an object of type
@objtype{mmec_intrep_\STEM\_t} as internal representation, rather than some other user--pointer
object type.
@end deftypefun


@deftypefun mmec_clang_\STEM\_t mmec_extract_clang_\STEM\_from_emacs_value (emacs_env * @var{ENV}, emacs_value @var{ARG})
Given the Emacs value @var{ARG}, in the context of the environment @var{ENV}: extract from it its
representation the raw C language value; return the value.  The returned value is independent from
the Emacs value @var{ARG}.

If @var{ARG} is not an Emacs user--pointer value: the @code{wrong-type-argument} error condition is
raised.  At the C language level: there is no way to validate @var{ARG} as having an object of type
@objtype{mmec_intrep_\STEM\_t} as internal representation, rather than some other user--pointer
object type.
@end deftypefun


@deftypefun mmec_clang_\STEM\_t mmec_extract_clang_\STEM\_from_intrep_\STEM\ (mmec_intrep_\STEM\_t @var{IREP})
Given the internal representation of a wrapper for the C language type @code{\CTYPE\}, extract and
return its value as raw C language value.  The returned value is independent from the internal
representation @var{IREP}.
@end deftypefun

@subsubheading Constructors

@deftypefun mmec_intrep_\STEM\_t mmec_new_intrep_\STEM\_from_clang_\STEM\ (mmec_clang_\STEM\_t @var{VAL})
Given the raw C language value @var{VAL} wrap it into its internal representation and return the
result.  The returned value is independent from @var{VAL}.

If an error occurs building the internal representation: an error is signalled and the return value
is @cnull{}.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_from_intrep_\STEM\ (emacs_env * @var{ENV}, mmec_intrep_\STEM\_t @var{IREP})
Given the internal representation @var{VAL} of a C language value: build and return a new Emacs
value, in the context of the environment @var{ENV}, representing the C language value.  The returned
object references @var{IREP} itself.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_from_clang_\STEM\ (emacs_env * @var{ENV}, mmec_clang_\STEM\_t @var{VAL})
Given a raw C language value: build and return a new Emacs value, in the context of the environment
@var{ENV}, representing the C language value itself.  The returned object is independent from
@var{VAL}.

If an error occurs building the internal representation: an error is signalled and the return value
is @nil{}.
@end deftypefun
@end macro

@c ------------------------------------------------------------------------

@menu
* capi objects clang char::     Wrapper of @code{char}.
* capi objects clang schar::    Wrapper of @code{signed char}.
* capi objects clang uchar::    Wrapper of @code{unsigned char}.
* capi objects clang wchar::    Wrapper of @code{wchar_t}.
* capi objects clang sshrt::    Wrapper of @code{signed short int}.
* capi objects clang ushrt::    Wrapper of @code{unsigned short int}.
* capi objects clang sint::     Wrapper of @code{signed int}.
* capi objects clang uint::     Wrapper of @code{unsigned int}.
* capi objects clang slong::    Wrapper of @code{signed long int}.
* capi objects clang ulong::    Wrapper of @code{unsigned long int}.
* capi objects clang sllong::   Wrapper of @code{signed long long int}.
* capi objects clang ullong::   Wrapper of @code{unsigned long long int}.
* capi objects clang sintmax::  Wrapper of @code{intmax_t}.
* capi objects clang uintmax::  Wrapper of @code{uintmax_t}.
* capi objects clang ssize::    Wrapper of @code{ssize_t}.
* capi objects clang usize::    Wrapper of @code{size_t}.
* capi objects clang ptrdiff::  Wrapper of @code{ptrdiff_t}.
* capi objects clang sint8::    Wrapper of @code{int8_t}.
* capi objects clang uint8::    Wrapper of @code{uint8_t}.
* capi objects clang sint16::   Wrapper of @code{int16_t}.
* capi objects clang uint16::   Wrapper of @code{uint16_t}.
* capi objects clang sint32::   Wrapper of @code{int32_t}.
* capi objects clang uint32::   Wrapper of @code{uint32_t}.
* capi objects clang sint64::   Wrapper of @code{int64_t}.
* capi objects clang uint64::   Wrapper of @code{uint64_t}.
* capi objects clang float::    Wrapper of @code{float}.
* capi objects clang double::   Wrapper of @code{double}.
* capi objects clang ldouble::  Wrapper of @code{long double}.
@end menu

@DocumentNumberValueWithIntegerRep{char, char}
@DocumentNumberValueWithIntegerRep{schar, signed char}
@DocumentNumberValueWithIntegerRep{uchar, unsigned char}
@DocumentNumberValueWithUsrptrRep{wchar, wchar_t}
@DocumentNumberValueWithIntegerRep{sshrt, signed short int}
@DocumentNumberValueWithIntegerRep{ushrt, unsigned short int}
@DocumentNumberValueWithUsrptrRep{sint, signed int}
@DocumentNumberValueWithUsrptrRep{uint, unsigned int}
@DocumentNumberValueWithUsrptrRep{slong, signed long int}
@DocumentNumberValueWithUsrptrRep{ulong, unsigned long int}
@DocumentNumberValueWithUsrptrRep{sllong, signed long long int}
@DocumentNumberValueWithUsrptrRep{ullong, unsigned long long int}
@DocumentNumberValueWithUsrptrRep{sintmax, intmax_t}
@DocumentNumberValueWithUsrptrRep{uintmax, uintmax_t}
@DocumentNumberValueWithUsrptrRep{ssize, ssize_t}
@DocumentNumberValueWithUsrptrRep{usize, size_t}
@DocumentNumberValueWithUsrptrRep{ptrdiff, ptrdiff_t}
@DocumentNumberValueWithIntegerRep{sint8, int8_t}
@DocumentNumberValueWithIntegerRep{uint8, uint8_t}
@DocumentNumberValueWithIntegerRep{sint16, int16_t}
@DocumentNumberValueWithIntegerRep{uint16, uint16_t}
@DocumentNumberValueWithUsrptrRep{sint32, int32_t}
@DocumentNumberValueWithUsrptrRep{uint32, uint32_t}
@DocumentNumberValueWithUsrptrRep{sint64, int64_t}
@DocumentNumberValueWithUsrptrRep{uint64, uint64_t}
@DocumentNumberValueWithUsrptrRep{float, float}
@DocumentNumberValueWithFloatRep{double, double}
@DocumentNumberValueWithUsrptrRep{ldouble, ldouble}

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

We can found informations and examples about Emacs modules at the repository mirror, under the
@file{modules} directory:

@center @url{https://github.com/emacs-mirror/emacs}

There is also a list of resources about Emacs modules:

@center @url{https://github.com/emacs-pe/emacs-modules}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

