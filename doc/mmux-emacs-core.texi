\input texinfo.tex
@c %**start of header
@setfilename mmux-emacs-core.info
@settitle MMUX Emacs Core
@c %**end of header

@include version.texi
@include macros.texi
@include elisp-macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      @mmux{} Emacs Core

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    @mmux{} Emacs Core

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmux-emacs-core

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2020

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              MMUX_EMACS_CORE
@set PackagePkgconfigModule             @code{mmux-emacs-core}
@set PackageLibsVar                     @env{MMUX_EMACS_CORE_LIBS}
@set PackageCflagsVar                   @env{MMUX_EMACS_CORE_CFLAGS}

@set PackageLibstem                     @file{mmux-emacs-core}
@set PackageSharedLibraryBasename       @file{libmmux-emacs-core}

@set PackageEmacsModule                 @file{cc-core}
@set PackageHeader                      mmux-emacs-core.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set PackageApiCPrefixLower             mmux_emacs_core_
@set PackageApiCPrefixUpper             MMUX_EMACS_CORE_
@set PackageApiElispPrefix              cc-

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@set RequiredEmacsVersion       26+

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------


@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This package installs a @gnu{} Emacs module on top of a C11 language library providing basic
infrastructure to write dynamic modules for Emacs.

The library supports @posix{} platforms.  This package is meant to work with @gnu{} Emacs version
@value{RequiredEmacsVersion}.  This package depends upon the external packages: @code{cl-lib}. To
run the test suite: this package requires the @code{ert} package.

This package is distributed under the terms of the @gnu{} General Public License (@gpl{}).

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}@*

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmux-emacs-core: (mmux-emacs-core).  MMUX Emacs Core a core library.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* constants::                   Constant values.
* ctypes::                      Object wrappers for C language types.
* bytevectors::                 Bytevector objects.
* errors::                      How errors are signalled.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

External documents

* modules: (elisp)Writing Dynamic Modules.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a @gnu{} Emacs module
implemented on top of a C11 language library; it provides basic infrastructure to write dynamic
modules for Emacs.

This package supports @posix{} platforms.  This package is meant to work with @gnu{} Emacs version
@value{RequiredEmacsVersion}.  This package depends upon the external packages: @code{cl-lib}.  To
run the test suite: this package requires the @code{ert} package.

@value{PACKAGE} installs the elisp modules @value{PackageEmacsModule}, @file{cc-constants} and a C
language shared library with basename @value{PackageSharedLibraryBasename} (using the @gnu{} Libtool
infrastructure).  All the elisp definition names are prefixed with
@code{@value{PackageApiElispPrefix}}.  The C language shared library is installed under
@samp{$libdir}, for example:

@center @file{/usr/local/lib64}

@noindent
while the elisp module goes under @samp{$lispdir}, for example:

@center @file{/usr/local/share/emacs/site-lisp}

@noindent
so to load the module (under an Emacs installation with dynamic modules enabled) we should do
something like:

@lisp
(add-to-list 'load-path "/usr/local/lib64"
                        "/usr/local/share/emacs/site-lisp")
(require 'cc-core)
@end lisp

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
It might be possible that we want to write a C language library making use of the facilities of this
package; so @value{PACKAGE} installs the single header file @value{PackageHeaderFile}.  All the C
language function names in the @api{} are prefixed with @code{@value{PackageApiCPrefixLower}}; all
the C language preprocessor symbol names are prefixed with @code{@value{PackageApiCPrefixUpper}};
all the type names are prefixed with @code{@value{PackageApiCPrefixLower}} and suffixed with
@code{_t}.

@menu
* overview linking::            Linking code with the library.
@end menu

@include overview-linking.texi

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@defun mmux-core-version-string
Return a string representing the interface version number.
@end defun


@defun mmux-core-version-interface-current
Return an integer representing the library interface current number.
@end defun


@defun mmux-core-version-interface-revision
Return an integer representing the library interface current revision number.
@end defun


@defun mmux-core-version-interface-age
Return an integer representing the library interface current age.
@end defun


@deftypefun {char const *} mmux_emacs_core_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int mmux_emacs_core_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int mmux_emacs_core_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int mmux_emacs_core_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node constants
@chapter Constant values


@menu
* constants sizeof::            Size of common C language types.
* constants limits::            Ranges representable by C language types.
* constants float::             Constants related to floating-point numbers.
@end menu

@c page
@node constants sizeof
@section Size of common C language types


The following syntactic bindings are defined in the module @file{cc-constants}, which is required by
@value{PackageEmacsModule}.


@deftypevr {Constant} integer cc-SIZEOF_CHAR
Size of @code{char} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_SIGNED_CHAR
Size of @code{signed char} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_UNSIGNED_CHAR
Size of @code{unsigned char} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_WCHAR
Size of @code{wchar_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_SIGNED_SHORT_INT
Size of @code{signed short int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_UNSIGNED_SHORT_INT
Size of @code{signed short int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_SIGNED_INT
Size of @code{signed int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_UNSIGNED_INT
Size of @code{signed int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_UNSIGNED_INT
Size of @code{unsigned int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_UNUNSIGNED_INT
Size of @code{unsigned int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_SIGNED_LONG_INT
Size of @code{signed long int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_UNSIGNED_LONG_INT
Size of @code{signed long int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_UNSIGNED_LONG_INT
Size of @code{unsigned long int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_UNUNSIGNED_LONG_INT
Size of @code{unsigned long int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_SIGNED_LONG_LONG_INT
Size of @code{signed long long int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_UNSIGNED_LONG_LONG_INT
Size of @code{signed long long int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_UNSIGNED_LONG_LONG_INT
Size of @code{unsigned long long int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_UNUNSIGNED_LONG_LONG_INT
Size of @code{unsigned long long int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_SIZE_T
Size of @code{size_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_SSIZE_T
Size of @code{ssize_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_INTMAX_T
Size of @code{intmax_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_UINTMAX_T
Size of @code{uintmax_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_INT8_T
Size of @code{int8_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_UINT8_T
Size of @code{uint8_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_INT16_T
Size of @code{int16_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_UINT16_T
Size of @code{uint16_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_INT32_T
Size of @code{int32_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_UINT32_T
Size of @code{uint32_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_INT64_T
Size of @code{int64_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_UINT64_T
Size of @code{uint64_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_FLOAT
Size of @code{float} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_DOUBLE
Size of @code{double} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer cc-SIZEOF_LONG_DOUBLE
Size of @code{long double} measured in bytes.
@end deftypevr

@c page
@node constants limits
@section Ranges representable by C language types


The following syntactic bindings are defined in the module @file{cc-constants}, which is required by
@value{PackageEmacsModule}.


@deftypevr {Constant} integer cc-SCHAR_MIN
Exact integer representing the minimum value representable by a @code{signed char}.
@end deftypevr


@deftypevr {Constant} integer cc-SCHAR_MAX
Exact integer representing the maximum value representable by a @code{signed char}.
@end deftypevr


@deftypevr {Constant} integer cc-CHAR_MIN
Exact integer representing the minimum value representable by a @code{char}.
@end deftypevr


@deftypevr {Constant} integer cc-CHAR_MAX
Exact integer representing the maximum value representable by a @code{char}.
@end deftypevr


@deftypevr {Constant} integer cc-UCHAR_MIN
Exact integer representing the minimum value representable by a @code{unsigned char}.
@end deftypevr


@deftypevr {Constant} integer cc-UCHAR_MAX
Exact integer representing the maximum value representable by a @code{unsigned char}.
@end deftypevr


@deftypevr {Constant} integer cc-SHRT_MIN
Exact integer representing the minimum value representable by a @code{signed short int}.
@end deftypevr


@deftypevr {Constant} integer cc-SHRT_MAX
Exact integer representing the maximum value representable by a @code{signed short int}.
@end deftypevr


@deftypevr {Constant} integer cc-USHRT_MIN
Exact integer representing the minimum value representable by a @code{unsigned short int}.
@end deftypevr


@deftypevr {Constant} integer cc-USHRT_MAX
Exact integer representing the maximum value representable by a @code{unsigned short int}.
@end deftypevr


@deftypevr {Constant} integer cc-INT_MIN
Exact integer representing the minimum value representable by a @code{signed int}.
@end deftypevr


@deftypevr {Constant} integer cc-INT_MAX
Exact integer representing the maximum value representable by a @code{signed int}.
@end deftypevr


@deftypevr {Constant} integer cc-UINT_MIN
Exact integer representing the minimum value representable by a @code{unsigned int}.
@end deftypevr


@deftypevr {Constant} integer cc-UINT_MAX
Exact integer representing the maximum value representable by a @code{unsigned int}.
@end deftypevr


@deftypevr {Constant} integer cc-LONG_MIN
Exact integer representing the minimum value representable by a @code{signed long int}.
@end deftypevr


@deftypevr {Constant} integer cc-LONG_MAX
Exact integer representing the maximum value representable by a @code{signed long int}.
@end deftypevr


@deftypevr {Constant} integer cc-ULONG_MIN
Exact integer representing the minimum value representable by a @code{unsigned long int}.
@end deftypevr


@deftypevr {Constant} integer cc-ULONG_MAX
Exact integer representing the maximum value representable by a @code{unsigned long int}.
@end deftypevr


@deftypevr {Constant} integer cc-LLONG_MIN
Exact integer representing the minimum value representable by a @code{signed long long int}.
@end deftypevr


@deftypevr {Constant} integer cc-LLONG_MAX
Exact integer representing the maximum value representable by a @code{signed long long int}.
@end deftypevr


@deftypevr {Constant} integer cc-ULLONG_MIN
Exact integer representing the minimum value representable by a @code{unsigned long long int}.
@end deftypevr


@deftypevr {Constant} integer cc-ULLONG_MAX
Exact integer representing the maximum value representable by a @code{unsigned long long int}.
@end deftypevr


@deftypevr {Constant} integer cc-WCHAR_MIN
Exact integer representing the minimum value representable by a @code{wchar_t}.
@end deftypevr


@deftypevr {Constant} integer cc-WCHAR_MAX
Exact integer representing the maximum value representable by a @code{wchar_t}.
@end deftypevr


@deftypevr {Constant} integer cc-SIZE_T_MIN
Exact integer representing the minimum value representable by a @code{size_t}.
@end deftypevr


@deftypevr {Constant} integer cc-SIZE_T_MAX
Exact integer representing the maximum value representable by a @code{size_t}.
@end deftypevr


@deftypevr {Constant} integer cc-SSIZE_T_MIN
Exact integer representing the minimum value representable by a @code{ssize_t}.
@end deftypevr


@deftypevr {Constant} integer cc-SSIZE_T_MAX
Exact integer representing the maximum value representable by a @code{ssize_t}.
@end deftypevr


@deftypevr {Constant} integer cc-INTMAX_MIN
Exact integer representing the minimum value representable by a @code{intmax_t}.
@end deftypevr


@deftypevr {Constant} integer cc-INTMAX_MAX
Exact integer representing the maximum value representable by a @code{intmax_t}.
@end deftypevr


@deftypevr {Constant} integer cc-UINTMAX_MIN
Exact integer representing the maximum value representable by a @code{uintmax_t}.
@end deftypevr


@deftypevr {Constant} integer cc-INT8_MIN
Exact integer representing the minimum value representable by a @code{int8_t}.
@end deftypevr


@deftypevr {Constant} integer cc-INT8_MAX
Exact integer representing the maximum value representable by a @code{int8_t}.
@end deftypevr


@deftypevr {Constant} integer cc-UINT8_MIN
Exact integer representing the minimum value representable by a @code{uint8_t}.
@end deftypevr


@deftypevr {Constant} integer cc-UINT8_MAX
Exact integer representing the maximum value representable by a @code{uint8_t}.
@end deftypevr


@deftypevr {Constant} integer cc-INT16_MIN
Exact integer representing the minimum value representable by a @code{int16_t}.
@end deftypevr


@deftypevr {Constant} integer cc-INT16_MAX
Exact integer representing the maximum value representable by a @code{int16_t}.
@end deftypevr


@deftypevr {Constant} integer cc-UINT16_MIN
Exact integer representing the minimum value representable by a @code{uint16_t}.
@end deftypevr


@deftypevr {Constant} integer cc-UINT16_MAX
Exact integer representing the maximum value representable by a @code{uint16_t}.
@end deftypevr


@deftypevr {Constant} integer cc-INT32_MIN
Exact integer representing the minimum value representable by a @code{int32_t}.
@end deftypevr


@deftypevr {Constant} integer cc-INT32_MAX
Exact integer representing the maximum value representable by a @code{int32_t}.
@end deftypevr


@deftypevr {Constant} integer cc-UINT32_MIN
Exact integer representing the minimum value representable by a @code{uint32_t}.
@end deftypevr


@deftypevr {Constant} integer cc-UINT32_MAX
Exact integer representing the maximum value representable by a @code{uint32_t}.
@end deftypevr


@deftypevr {Constant} integer cc-INT64_MIN
Exact integer representing the minimum value representable by a @code{int64_t}.
@end deftypevr


@deftypevr {Constant} integer cc-INT64_MAX
Exact integer representing the maximum value representable by a @code{int64_t}.
@end deftypevr


@deftypevr {Constant} integer cc-UINT64_MIN
Exact integer representing the minimum value representable by a @code{uint64_t}.
@end deftypevr


@deftypevr {Constant} integer cc-UINT64_MAX
Exact integer representing the maximum value representable by a @code{uint64_t}.
@end deftypevr

@c page
@node constants float
@section Constants related to floating--point numbers


The following syntactic bindings are defined in the module @file{cc-constants}, which is required by
@value{PackageEmacsModule}.


@defvr {Constant} cc-FLT_ROUNDS
Value of the system constant @code{FLT_ROUNDS}.
@end defvr


@defvr {Constant} cc-FLT_RADIX
Value of the system constant @code{FLT_RADIX}.
@end defvr


@defvr {Constant} cc-FLT_MANT_DIG
Value of the system constant @code{FLT_MANT_DIG}.
@end defvr


@defvr {Constant} cc-DBL_MANT_DIG
Value of the system constant @code{DBL_MANT_DIG}.
@end defvr


@defvr {Constant} cc-LDBL_MANT_DIG
Value of the system constant @code{LDBL_MANT_DIG}.
@end defvr


@defvr {Constant} cc-FLT_DIG
Value of the system constant @code{FLT_DIG}.
@end defvr


@defvr {Constant} cc-DBL_DIG
Value of the system constant @code{DBL_DIG}.
@end defvr


@defvr {Constant} cc-LDBL_DIG
Value of the system constant @code{LDBL_DIG}.
@end defvr


@defvr {Constant} cc-FLT_MIN_EXP
Value of the system constant @code{FLT_MIN_EXP}.
@end defvr


@defvr {Constant} cc-DBL_MIN_EXP
Value of the system constant @code{DBL_MIN_EXP}.
@end defvr


@defvr {Constant} cc-LDBL_MIN_EXP
Value of the system constant @code{LDBL_MIN_EXP}.
@end defvr


@defvr {Constant} cc-FLT_MIN_10_EXP
Value of the system constant @code{FLT_MIN_10_EXP}.
@end defvr


@defvr {Constant} cc-DBL_MIN_10_EXP
Value of the system constant @code{DBL_MIN_10_EXP}.
@end defvr


@defvr {Constant} cc-LDBL_MIN_10_EXP
Value of the system constant @code{LDBL_MIN_10_EXP}.
@end defvr


@defvr {Constant} cc-FLT_MAX_EXP
Value of the system constant @code{FLT_MAX_EXP}.
@end defvr


@defvr {Constant} cc-DBL_MAX_EXP
Value of the system constant @code{DBL_MAX_EXP}.
@end defvr


@defvr {Constant} cc-LDBL_MAX_EXP
Value of the system constant @code{LDBL_MAX_EXP}.
@end defvr


@defvr {Constant} cc-FLT_MAX_10_EXP
Value of the system constant @code{FLT_MAX_10_EXP}.
@end defvr


@defvr {Constant} cc-DBL_MAX_10_EXP
Value of the system constant @code{DBL_MAX_10_EXP}.
@end defvr


@defvr {Constant} cc-LDBL_MAX_10_EXP
Value of the system constant @code{LDBL_MAX_10_EXP}.
@end defvr


@defvr {Constant} cc-FLT_MAX
Value of the system constant @code{FLT_MAX}.
@end defvr


@defvr {Constant} cc-DBL_MAX
Value of the system constant @code{DBL_MAX}.
@end defvr


@defvr {Constant} cc-LDBL_MAX
Value of the system constant @code{LDBL_MAX}.
@end defvr


@defvr {Constant} cc-FLT_MIN
Value of the system constant @code{FLT_MIN}.
@end defvr


@defvr {Constant} cc-DBL_MIN
Value of the system constant @code{DBL_MIN}.
@end defvr


@defvr {Constant} cc-LDBL_MIN
Value of the system constant @code{LDBL_MIN}.
@end defvr


@defvr {Constant} cc-FLT_EPSILON
Value of the system constant @code{FLT_EPSILON}.
@end defvr


@defvr {Constant} cc-DBL_EPSILON
Value of the system constant @code{DBL_EPSILON}.
@end defvr


@defvr {Constant} cc-LDBL_EPSILON
Value of the system constant @code{LDBL_EPSILON}.
@end defvr

@c page
@node ctypes
@chapter Object wrappers for C language types.


@value{PACKAGE} defines elisp data types in the module @value{PackageEmacsModule}.  Many wrappers
for integer types are implemented for safety of writing interfaces to C language library and for
better dispatching of multimethods.

@quotation
@strong{NOTE} At the time of this writing (Feb 2, 2020) @gnu{} Emacs version 26 internally
represents exact integer objects with values of type C language @code{intmax_t}, but not the whole
range of such type is available.
@end quotation

@menu
* ctypes typedefs::             Object type definitions.
* ctypes comparison::           Comparison operations.
@end menu

@c page
@node ctypes typedefs
@section Object type definitions


@menu
* ctypes typedefs base::        Base type definitions.
* ctypes typedefs char::        Wrapper for @code{char}.
* ctypes typedefs schar::       Wrapper for @code{signed char}.
* ctypes typedefs uchar::       Wrapper for @code{unsigned char}.
* ctypes typedefs wchar::       Wrapper for @code{wchar_t}.
* ctypes typedefs sshrt::       Wrapper for @code{signed short int}.
* ctypes typedefs ushrt::       Wrapper for @code{unsigned short int}.
* ctypes typedefs sint::        Wrapper for @code{signed int}.
* ctypes typedefs uint::        Wrapper for @code{unsigned int}.
* ctypes typedefs slong::       Wrapper for @code{signed long int}.
* ctypes typedefs ulong::       Wrapper for @code{unsigned long int}.
* ctypes typedefs sllong::      Wrapper for @code{signed long long int}.
* ctypes typedefs ullong::      Wrapper for @code{unsigned long long int}.
* ctypes typedefs ssize::       Wrapper for @code{ssize_t}.
* ctypes typedefs usize::       Wrapper for @code{size_t}.
* ctypes typedefs sintmax::     Wrapper for @code{intmax_t}.
* ctypes typedefs uintmax::     Wrapper for @code{uintmax_t}.
* ctypes typedefs ptrdiff::     Wrapper for @code{ptrdiff_t}.
* ctypes typedefs sint8::       Wrapper for @code{int8_t}.
* ctypes typedefs uint8::       Wrapper for @code{uint8_t}.
* ctypes typedefs sint16::      Wrapper for @code{int16_t}.
* ctypes typedefs uint16::      Wrapper for @code{uint16_t}.
* ctypes typedefs sint32::      Wrapper for @code{int32_t}.
* ctypes typedefs uint32::      Wrapper for @code{uint32_t}.
* ctypes typedefs sint64::      Wrapper for @code{int64_t}.
* ctypes typedefs uint64::      Wrapper for @code{uint64_t}.
* ctypes typedefs float::       Wrapper for @code{float}.
* ctypes typedefs long double:: Wrapper for @code{long double}.
@end menu

@c page
@node ctypes typedefs base
@subsection Base type definitions


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.  All the
following types are to be considered ``abstract'', so we must not instantiate them.


@deftp {Abstract Object Type} cc-number
Base type of all the custom number types defined by this module.
@end deftp


@deftp {Abstract Object Type} cc-integer
@deftpx {Parent Type} cc-number
Base type of all the custom exact integer number types defined by this module.
@end deftp


@deftp {Abstract Object Type} cc-signed-integer
@deftpx {Parent Type} cc-integer
Base type of all the custom exact signed integer number types defined by this module.
@end deftp


@deftp {Abstract Object Type} cc-unsigned-integer
@deftpx {Parent Type} cc-integer
Base type of all the custom exact unsigned integer number types defined by this module.
@end deftp


@deftp {Abstract Object Type} cc-floating-point
@deftpx {Parent Type} cc-number
Base type of all the custom floating--point number types defined by this module.
@end deftp


@defun cc-number-p @var{OBJ}
@defunx cc-integer-p @var{OBJ}
@defunx cc-signed-integer-p @var{OBJ}
@defunx cc-unsigned-integer-p @var{OBJ}
@defunx cc-floating-point-p @var{OBJ}
Return true if @var{OBJ} is an instance of the specified type; otherwise return false.
@end defun

@c page
@node ctypes typedefs char
@subsection Wrapper for @code{char}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-char
@deftpx {Parent Type} cc-signed-integer
Object wrapper for the C language type @code{char}.
@end deftp


@deffn {Generic Function} cc-char (@var{INIT})
@deffnx {Method} cc-char ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-char} initialised with @var{INIT}, which must be an
exact integer object in the range of the C language type @code{char}.
@end deffn


@defun cc-char-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-char}, otherwise return false.
@end defun


@defun cc-char-obj @var{CH}
Given an instance of @objtype{cc-char}: return the exact integer representing its @ascii{} code.
@end defun


@defun cc-char-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{char}.
@end defun

@c page
@node ctypes typedefs schar
@subsection Wrapper for @code{signed char}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-schar
@deftpx {Parent Type} cc-signed-integer
Object wrapper for the C language type @code{signed char}.
@end deftp


@deffn {Generic Function} cc-schar (@var{INIT})
@deffnx {Method} cc-schar ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-schar} initialised with @var{INIT}, which must be an
exact integer object in the range of the C language type @code{signed char}.
@end deffn


@defun cc-schar-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-schar}, otherwise return false.
@end defun


@defun cc-schar-obj @var{CH}
Given an instance of @objtype{cc-schar}: return the exact integer representing its @ascii{} code.
@end defun


@defun cc-schar-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{signed char}.
@end defun

@c page
@node ctypes typedefs uchar
@subsection Wrapper for @code{unsigned char}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-uchar
@deftpx {Parent Type} cc-unsigned-integer
Object wrapper for the C language type @code{unsigned char}.
@end deftp


@deffn {Generic Function} cc-uchar (@var{INIT})
@deffnx {Method} cc-uchar ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-uchar} initialised with @var{INIT}, which must be an
exact integer object in the range of the C language type @code{unsigned char}.
@end deffn


@defun cc-uchar-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-uchar}, otherwise return false.
@end defun


@defun cc-uchar-obj @var{CH}
Given an instance of @objtype{cc-uchar}: return the exact integer representing its @ascii{} code.
@end defun


@defun cc-uchar-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{unsigned char}.
@end defun

@c page
@node ctypes typedefs wchar
@subsection Wrapper for @code{wchar_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-wchar
@deftpx {Parent Type} cc-unsigned-integer
Object wrapper for the C language type @code{wchar_t}.
@end deftp


@deffn {Generic Function} cc-wchar (@var{INIT})
@deffnx {Method} cc-wchar ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-wchar} initialised with @var{INIT}, which must be an
exact integer object in the range of the C language type @code{wchar_t}.
@end deffn


@defun cc-wchar-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-wchar}, otherwise return false.
@end defun


@defun cc-wchar-obj @var{CH}
Given an instance of @objtype{cc-wchar}: return the exact integer representing its @ascii{} code.
@end defun


@defun cc-wchar-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{wchar_t}.
@end defun

@c page
@node ctypes typedefs sshrt
@subsection Wrapper for @code{signed short int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-signed-short-int
@deftpx {Parent Type} cc-signed-integer
Object wrapper for the C language type @code{signed short int}.
@end deftp


@deffn {Generic Function} cc-signed-short-int (@var{INIT})
@deffnx {Method} cc-signed-short-int ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-signed-short-int} initialised with @var{INIT}, which
must be an exact integer object in the range of the C language type @code{signed short int}.
@end deffn


@defun cc-signed-short-int-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-signed-short-int}, otherwise return false.
@end defun


@defun cc-signed-short-int-obj @var{CH}
Given an instance of @objtype{cc-signed-short-int}: return the exact integer representing its
@ascii{} code.
@end defun


@defun cc-signed-short-int-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{signed short int}.
@end defun

@c page
@node ctypes typedefs ushrt
@subsection Wrapper for @code{unsigned short int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-unsigned-short-int
@deftpx {Parent Type} cc-unsigned-integer
Object wrapper for the C language type @code{unsigned short int}.
@end deftp


@deffn {Generic Function} cc-unsigned-short-int (@var{INIT})
@deffnx {Method} cc-unsigned-short-int ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-unsigned-short-int} initialised with @var{INIT},
which must be an exact integer object in the range of the C language type @code{unsigned short int}.
@end deffn


@defun cc-unsigned-short-int-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-unsigned-short-int}, otherwise return false.
@end defun


@defun cc-unsigned-short-int-obj @var{CH}
Given an instance of @objtype{cc-unsigned-short-int}: return the exact integer representing its
@ascii{} code.
@end defun


@defun cc-unsigned-short-int-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{unsigned short int}.
@end defun

@c page
@node ctypes typedefs sint
@subsection Wrapper for @code{signed int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-signed-int
@deftpx {Parent Type} cc-signed-integer
Object wrapper for the C language type @code{signed int}.
@end deftp


@deffn {Generic Function} cc-signed-int (@var{INIT})
@deffnx {Method} cc-signed-int ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-signed-int} initialised with @var{INIT}, which
must be an exact integer object in the range of the C language type @code{signed int}.
@end deffn


@defun cc-signed-int-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-signed-int}, otherwise return false.
@end defun


@defun cc-signed-int-obj @var{CH}
Given an instance of @objtype{cc-signed-int}: return the its internal representation as
user--pointer object.
@end defun


@defun cc-signed-int-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{signed int}.
@end defun

@c page
@node ctypes typedefs uint
@subsection Wrapper for @code{unsigned int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-unsigned-int
@deftpx {Parent Type} cc-unsigned-integer
Object wrapper for the C language type @code{unsigned int}.
@end deftp


@deffn {Generic Function} cc-unsigned-int (@var{INIT})
@deffnx {Method} cc-unsigned-int ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-unsigned-int} initialised with @var{INIT}, which must
be an exact integer object in the range of the C language type @code{unsigned int}.
@end deffn


@defun cc-unsigned-int-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-unsigned-int}, otherwise return false.
@end defun


@defun cc-unsigned-int-obj @var{CH}
Given an instance of @objtype{cc-unsigned-int}: return the its internal representation as
user--pointer object.
@end defun


@defun cc-unsigned-int-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{unsigned int}.
@end defun

@c page
@node ctypes typedefs slong
@subsection Wrapper for @code{signed long int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-signed-long-int
@deftpx {Parent Type} cc-signed-integer
Object wrapper for the C language type @code{signed long int}.
@end deftp


@deffn {Generic Function} cc-signed-long-int (@var{INIT})
@deffnx {Method} cc-signed-long-int ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-signed-long-int} initialised with @var{INIT}, which
must be an exact integer object in the range of the C language type @code{signed long int}.
@end deffn


@defun cc-signed-long-int-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-signed-long-int}, otherwise return false.
@end defun


@defun cc-signed-long-int-obj @var{CH}
Given an instance of @objtype{cc-signed-long-int}: return the its internal representation as
user--pointer object.
@end defun


@defun cc-signed-long-int-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{signed long int}.
@end defun

@c page
@node ctypes typedefs ulong
@subsection Wrapper for @code{unsigned long int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-unsigned-long-int
@deftpx {Parent Type} cc-unsigned-integer
Object wrapper for the C language type @code{unsigned long int}.
@end deftp


@deffn {Generic Function} cc-unsigned-long-int (@var{INIT})
@deffnx {Method} cc-unsigned-long-int ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-unsigned-long-int} initialised with @var{INIT}, which
must be an exact integer object in the range of the C language type @code{unsigned long int}.
@end deffn


@defun cc-unsigned-long-int-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-unsigned-long-int}, otherwise return false.
@end defun


@defun cc-unsigned-long-int-obj @var{CH}
Given an instance of @objtype{cc-unsigned-long-int}: return the its internal representation as
user--pointer object.
@end defun


@defun cc-unsigned-long-int-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{unsigned long int}.
@end defun

@c page
@node ctypes typedefs sllong
@subsection Wrapper for @code{signed long long int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-signed-long-long-int
@deftpx {Parent Type} cc-signed-integer
Object wrapper for the C language type @code{signed long long int}.
@end deftp


@deffn {Generic Function} cc-signed-long-long-int (@var{INIT})
@deffnx {Method} cc-signed-long-long-int ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-signed-long-long-int} initialised with @var{INIT},
which must be an exact integer object in the range of the C language type @code{signed long long
int}.
@end deffn


@defun cc-signed-long-long-int-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-signed-long-long-int}, otherwise return
false.
@end defun


@defun cc-signed-long-long-int-obj @var{CH}
Given an instance of @objtype{cc-signed-long-long-int}: return the its internal representation as
user--pointer object.
@end defun


@defun cc-signed-long-long-int-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{signed long long int}.
@end defun

@c page
@node ctypes typedefs ullong
@subsection Wrapper for @code{unsigned long long int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-unsigned-long-long-int
@deftpx {Parent Type} cc-unsigned-integer
Object wrapper for the C language type @code{unsigned long long int}.
@end deftp


@deffn {Generic Function} cc-unsigned-long-long-int (@var{INIT})
@deffnx {Method} cc-unsigned-long-long-int ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-unsigned-long-long-int} initialised with @var{INIT},
which must be an exact integer object in the range of the C language type @code{unsigned long long
int}.
@end deffn


@defun cc-unsigned-long-long-int-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-unsigned-long-long-int}, otherwise return
false.
@end defun


@defun cc-unsigned-long-long-int-obj @var{CH}
Given an instance of @objtype{cc-unsigned-long-long-int}: return the its internal representation as
user--pointer object.
@end defun


@defun cc-unsigned-long-long-int-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{unsigned long long int}.
@end defun

@c page
@node ctypes typedefs ssize
@subsection Wrapper for @code{ssize_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-ssize
@deftpx {Parent Type} cc-signed-integer
Object wrapper for the C language type @code{ssize_t}.
@end deftp


@deffn {Generic Function} cc-ssize (@var{INIT})
@deffnx {Method} cc-ssize ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-ssize} initialised with @var{INIT}, which must be an
exact integer object in the range of the C language type @code{ssize_t}.
@end deffn


@defun cc-ssize-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-ssize}, otherwise return false.
@end defun


@defun cc-ssize-obj @var{CH}
Given an instance of @objtype{cc-ssize}: return the its internal representation as user--pointer
object.
@end defun


@defun cc-ssize-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{ssize_t}.
@end defun

@c page
@node ctypes typedefs usize
@subsection Wrapper for @code{size_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-usize
@deftpx {Parent Type} cc-unsigned-integer
Object wrapper for the C language type @code{size_t}.
@end deftp


@deffn {Generic Function} cc-usize (@var{INIT})
@deffnx {Method} cc-usize ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-usize} initialised with @var{INIT}, which must be an
exact integer object in the range of the C language type @code{size_t}.
@end deffn


@defun cc-usize-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-usize}, otherwise return false.
@end defun


@defun cc-usize-obj @var{CH}
Given an instance of @objtype{cc-usize}: return the its internal representation as user--pointer
object.
@end defun


@defun cc-usize-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{size_t}.
@end defun

@c page
@node ctypes typedefs sintmax
@subsection Wrapper for @code{intmax_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-sintmax
@deftpx {Parent Type} cc-signed-integer
Object wrapper for the C language type @code{intmax_t}.
@end deftp


@deffn {Generic Function} cc-sintmax (@var{INIT})
@deffnx {Method} cc-sintmax ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-sintmax} initialised with @var{INIT}, which must be an
exact integer object in the range of the C language type @code{intmax_t}.
@end deffn


@defun cc-sintmax-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-sintmax}, otherwise return false.
@end defun


@defun cc-sintmax-obj @var{CH}
Given an instance of @objtype{cc-sintmax}: return the its internal representation as user--pointer
object.
@end defun


@defun cc-sintmax-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{intmax_t}.
@end defun

@c page
@node ctypes typedefs uintmax
@subsection Wrapper for @code{uintmax_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-uintmax
@deftpx {Parent Type} cc-unsigned-integer
Object wrapper for the C language type @code{uintmax_t}.
@end deftp


@deffn {Generic Function} cc-uintmax (@var{INIT})
@deffnx {Method} cc-uintmax ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-uintmax} initialised with @var{INIT}, which must be
an exact integer object in the range of the C language type @code{uintmax_t}.
@end deffn


@defun cc-uintmax-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-uintmax}, otherwise return false.
@end defun


@defun cc-uintmax-obj @var{CH}
Given an instance of @objtype{cc-uintmax}: return the its internal representation as user--pointer
object.
@end defun


@defun cc-uintmax-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{uintmax}.
@end defun

@c page
@node ctypes typedefs ptrdiff
@subsection Wrapper for @code{ptrdiff_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-ptrdiff
@deftpx {Parent Type} cc-signed-integer
Object wrapper for the C language type @code{ptrdiff_t}.
@end deftp


@deffn {Generic Function} cc-ptrdiff (@var{INIT})
@deffnx {Method} cc-ptrdiff ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-ptrdiff} initialised with @var{INIT}, which must be
an exact integer object in the range of the C language type @code{ptrdiff_t}.
@end deffn


@defun cc-ptrdiff-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-ptrdiff}, otherwise return false.
@end defun


@defun cc-ptrdiff-obj @var{CH}
Given an instance of @objtype{cc-ptrdiff}: return the its internal representation as user--pointer
object.
@end defun


@defun cc-ptrdiff-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{ptrdiff}.
@end defun

@c page
@node ctypes typedefs sint8
@subsection Wrapper for @code{int8_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-sint8
@deftpx {Parent Type} cc-signed-integer
Object wrapper for the C language type @code{int8_t}.
@end deftp


@deffn {Generic Function} cc-sint8 (@var{INIT})
@deffnx {Method} cc-sint8 ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-sint8} initialised with @var{INIT}, which must be an
exact integer object in the range of the C language type @code{int8_t}.
@end deffn


@defun cc-sint8-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-sint8}, otherwise return false.
@end defun


@defun cc-sint8-obj @var{CH}
Given an instance of @objtype{cc-sint8}: return the its internal representation as user--pointer
object.
@end defun


@defun cc-sint8-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{int8_t}.
@end defun

@c page
@node ctypes typedefs uint8
@subsection Wrapper for @code{uint8_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-uint8
@deftpx {Parent Type} cc-unsigned-integer
Object wrapper for the C language type @code{uint8_t}.
@end deftp


@deffn {Generic Function} cc-uint8 (@var{INIT})
@deffnx {Method} cc-uint8 ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-uint8} initialised with @var{INIT}, which must be an
exact integer object in the range of the C language type @code{uint8_t}.
@end deffn


@defun cc-uint8-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-uint8}, otherwise return false.
@end defun


@defun cc-uint8-obj @var{CH}
Given an instance of @objtype{cc-uint8}: return the its internal representation as user--pointer
object.
@end defun


@defun cc-uint8-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{uint8_t}.
@end defun

@c page
@node ctypes typedefs sint16
@subsection Wrapper for @code{int16_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-sint16
@deftpx {Parent Type} cc-signed-integer
Object wrapper for the C language type @code{int16_t}.
@end deftp


@deffn {Generic Function} cc-sint16 (@var{INIT})
@deffnx {Method} cc-sint16 ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-sint16} initialised with @var{INIT}, which must be an
exact integer object in the range of the C language type @code{int16_t}.
@end deffn


@defun cc-sint16-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-sint16}, otherwise return false.
@end defun


@defun cc-sint16-obj @var{CH}
Given an instance of @objtype{cc-sint16}: return the its internal representation as user--pointer
object.
@end defun


@defun cc-sint16-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{int16_t}.
@end defun

@c page
@node ctypes typedefs uint16
@subsection Wrapper for @code{uint16_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-uint16
@deftpx {Parent Type} cc-unsigned-integer
Object wrapper for the C language type @code{uint16_t}.
@end deftp


@deffn {Generic Function} cc-uint16 (@var{INIT})
@deffnx {Method} cc-uint16 ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-uint16} initialised with @var{INIT}, which must be an
exact integer object in the range of the C language type @code{uint16_t}.
@end deffn


@defun cc-uint16-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-uint16}, otherwise return false.
@end defun


@defun cc-uint16-obj @var{CH}
Given an instance of @objtype{cc-uint16}: return the its internal representation as user--pointer
object.
@end defun


@defun cc-uint16-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{uint16_t}.
@end defun

@c page
@node ctypes typedefs sint32
@subsection Wrapper for @code{int32_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-sint32
@deftpx {Parent Type} cc-signed-integer
Object wrapper for the C language type @code{int32_t}.
@end deftp


@deffn {Generic Function} cc-sint32 (@var{INIT})
@deffnx {Method} cc-sint32 ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-sint32} initialised with @var{INIT}, which must be an
exact integer object in the range of the C language type @code{int32_t}.
@end deffn


@defun cc-sint32-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-sint32}, otherwise return false.
@end defun


@defun cc-sint32-obj @var{CH}
Given an instance of @objtype{cc-sint32}: return the its internal representation as user--pointer
object.
@end defun


@defun cc-sint32-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{int32_t}.
@end defun

@c page
@node ctypes typedefs uint32
@subsection Wrapper for @code{uint32_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-uint32
@deftpx {Parent Type} cc-unsigned-integer
Object wrapper for the C language type @code{uint32_t}.
@end deftp


@deffn {Generic Function} cc-uint32 (@var{INIT})
@deffnx {Method} cc-uint32 ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-uint32} initialised with @var{INIT}, which must be an
exact integer object in the range of the C language type @code{uint32_t}.
@end deffn


@defun cc-uint32-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-uint32}, otherwise return false.
@end defun


@defun cc-uint32-obj @var{CH}
Given an instance of @objtype{cc-uint32}: return the its internal representation as user--pointer
object.
@end defun


@defun cc-uint32-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{uint32_t}.
@end defun

@c page
@node ctypes typedefs sint64
@subsection Wrapper for @code{int64_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-sint64
@deftpx {Parent Type} cc-signed-integer
Object wrapper for the C language type @code{int64_t}.
@end deftp


@deffn {Generic Function} cc-sint64 (@var{INIT})
@deffnx {Method} cc-sint64 ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-sint64} initialised with @var{INIT}, which must be an
exact integer object in the range of the C language type @code{int64_t}.
@end deffn


@defun cc-sint64-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-sint64}, otherwise return false.
@end defun


@defun cc-sint64-obj @var{CH}
Given an instance of @objtype{cc-sint64}: return the its internal representation as user--pointer
object.
@end defun


@defun cc-sint64-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{int64_t}.
@end defun

@c page
@node ctypes typedefs uint64
@subsection Wrapper for @code{uint64_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-uint64
@deftpx {Parent Type} cc-unsigned-integer
Object wrapper for the C language type @code{uint64_t}.
@end deftp


@deffn {Generic Function} cc-uint64 (@var{INIT})
@deffnx {Method} cc-uint64 ((@var{INIT} integer))
Build and return a new instance of @objtype{cc-uint64} initialised with @var{INIT}, which must be an
exact integer object in the range of the C language type @code{uint64_t}.
@end deffn


@defun cc-uint64-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-uint64}, otherwise return false.
@end defun


@defun cc-uint64-obj @var{CH}
Given an instance of @objtype{cc-uint64}: return the its internal representation as user--pointer
object.
@end defun


@defun cc-uint64-range-p @var{OBJ}
Return true if @var{OBJ} is an exact integer object and it is in the range representable by
@code{uint64_t}.
@end defun

@c page
@node ctypes typedefs float
@subsection Wrapper for @code{float}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-float
@deftpx {Parent Type} cc-floating-point
Object wrapper for the C language type @code{float}.
@end deftp


@deffn {Generic Function} cc-float (@var{INIT})
@deffnx {Method} cc-float ((@var{INIT} float))
Build and return a new instance of @objtype{cc-float} initialised with @var{INIT}, which must be a
floating--point object in the range of the C language type @code{float}.
@end deffn


@defun cc-float-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-float}, otherwise return false.
@end defun


@defun cc-float-obj @var{CH}
Given an instance of @objtype{cc-float}: return the its internal representation as user--pointer
object.
@end defun


@defun cc-float-range-p @var{OBJ}
Return true if @var{OBJ} is a floating--point object and it is in the range representable by
@code{float}.
@end defun

@c page
@node ctypes typedefs long double
@subsection Wrapper for @code{long double}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@deftp {Object Type} cc-long-double
@deftpx {Parent Type} cc-floating-point
Object wrapper for the C language type @code{long double}.
@end deftp


@deffn {Generic Function} cc-long-double (@var{INIT})
@deffnx {Method} cc-long-double ((@var{INIT} float))
Build and return a new instance of @objtype{cc-long-double} initialised with @var{INIT}, which must
be a floating--point object in the range of the C language type @code{long double}.
@end deffn


@defun cc-long-double-p @var{obj}
Return true if @var{obj} is an instance of @objtype{cc-long-double}, otherwise return false.
@end defun


@defun cc-long-double-obj @var{CH}
Given an instance of @objtype{cc-long-double}: return the its internal representation as
user--pointer object.
@end defun


@defun cc-long-double-range-p @var{OBJ}
Return true if @var{OBJ} is a floating--point object and it is in the range representable by
@code{long double}.
@end defun

@c page
@node ctypes comparison
@section Comparison operations


To perform a comparison operation among operands of different types, we normalise the operands as
follows:

@itemize
@item
We convert all the signed integers to @objtype{cc-sint64}.

@item
We convert all the unsigned integers to @objtype{cc-uint64}.

@item
We convert all the floating--point numbers to @objtype{cc-long-double}.

@item
When comparing integers and floating--point numbers we convert all the integer types to
@objtype{cc-long-double}.
@end itemize

@c ------------------------------------------------------------------------


@macro mmuxDefunNumericComparisonMethod{OPERATOR, TYPE1, TYPE2}
@deffn {Method} cc-2\OPERATOR\ ((@vari{op} \TYPE1\) (@varii{op} \TYPE2\))
Return true if @vari{OP} \OPERATOR\ @varii{OP}; otherwise return false.
@end deffn

@end macro


@macro mmuxDefunNumericComparisonFunction{OPERATOR, OPERATIONDESCRIPTION}
@defun cc\OPERATOR\ @var{OP} &rest @var{ops}
Return true if all the operands are \OPERATIONDESCRIPTION\, left to right; otherwise return false.
The comparison is performed with the generic function @func{cc-2\OPERATOR\}.
@end defun


@deffn {Generic Function} {cc-2\OPERATOR\} (@vari{OP} @varii{OP})
Return true if @vari{OP} \OPERATOR\ @varii{OP}; otherwise return false.
@end deffn

@c These are the methods that actually do the operation on built-in numeric objects.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, integer, integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, integer, float}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, float,   integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, float,   float}

@c These are the methods that actually do the operation on custom user-pointer objects.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-sint64, cc-sint64}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-uint64, cc-uint64}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-sint64, cc-uint64}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-uint64, cc-sint64}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-long-double, cc-long-double}

@c These are the methods that normalise operands among operational types.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-sint64, cc-long-double}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-uint64, cc-long-double}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-long-double, cc-sint64}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-long-double, cc-uint64}

@c These are the methods that normalise among integer types.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-signed-integer,   cc-signed-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-unsigned-integer, cc-unsigned-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-signed-integer,   cc-unsigned-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-unsigned-integer, cc-signed-integer}

@c These are the methods that normalise among floating point types.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-floating-point, cc-floating-point}

@c These are the methods that normalise mixed numeric types: `cc-floating-point', `cc-signed-integer', `cc-unsigned-intger'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-floating-point,   cc-signed-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-signed-integer,   cc-floating-point}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-floating-point,   cc-unsigned-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-unsigned-integer, cc-floating-point}

@c These are the methods that normalise mixed numeric types: `integer' and `cc-floating-point'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, integer, cc-floating-point}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-floating-point, integer}

@c These are the methods that normalise mixed numeric types: `integer' and `cc-signed-integer'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, integer, cc-signed-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-signed-integer, integer}

@c These are the methods that normalise mixed numeric types: `integer' and `cc-unsigned-integer'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, integer, cc-unsigned-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-unsigned-integer, integer}

@c These are the methods that normalise mixed numeric types: `float' and `cc-floating-point'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, float, cc-floating-point}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-floating-point, float}

@c These are the methods that normalise mixed numeric types: `float' and `cc-signed-integer'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, float, cc-signed-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-signed-integer, float}

@c These are the methods that normalise mixed numeric types: `float' and `cc-unsigned-integer'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, float, cc-unsigned-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, cc-unsigned-integer, float}
@end macro

@c ------------------------------------------------------------------------

@menu
* ctypes comparison eq::        Equality functions.
* ctypes comparison neq::       Non-equality functions.
* ctypes comparison less::      Less than functions.
* ctypes comparison greater::   Greater than functions.
* ctypes comparison leq::       Less than or equal to functions.
* ctypes comparison geq::       Greater than or equal to functions.
@end menu

@c page
@node ctypes comparison eq
@subsection Equality functions


@mmuxDefunNumericComparisonFunction{=, one equal to the other}

@c page
@node ctypes comparison neq
@subsection Non--equality functions


@mmuxDefunNumericComparisonFunction{/=, one not equal to the other}

@c page
@node ctypes comparison less
@subsection Less than functions


@mmuxDefunNumericComparisonFunction{<, one less than the other}

@c page
@node ctypes comparison greater
@subsection Greater than functions


@mmuxDefunNumericComparisonFunction{>, one greater than the other}

@c page
@node ctypes comparison leq
@subsection Less than or equal to functions


@mmuxDefunNumericComparisonFunction{<=, one less than or equal to the other}

@c page
@node ctypes comparison geq
@subsection Greater than or equal to functions


@mmuxDefunNumericComparisonFunction{>=, one greater than or equal to the other}

@c page
@node bytevectors
@chapter Bytevector objects


@menu
* bytevectors typedefs::        Type definition.
* bytevectors pred::            Type predicates.
* bytevectors getters::         Bytevector getters.
* bytevectors setters::         Bytevector setters.
@end menu

@c page
@node bytevectors typedefs
@section Type definition


@deftp {Object Type} cc-bytevector
Base type of bytevector objects: it can represent binary data with a C language array.  Objects of
this type are correctly garbage collected.  It has the following fields:

@table @code
@item number-of-slots
Non--negative exact integer representing the number of slots in a bytevector.

@item slot-size
Non--negative exact integer representing the size of a slot measured in bytes.

@item number-of-allocated-bytes
Non--negative exact integer representing the number of bytes allocated in the data area.

@item obj
Pointer object.
@end table
@end deftp


@deftp {Object Type} cc-integer-bytevector
@deftpx {Parent Type} cc-bytevector
Base type of bytevector objects holding C language integers in their slots.  Objects of this type
are correctly garbage collected.  In addition to the slots of @objtype{cc-bytevector}, it has the
following fields:

@table @code
@item signed
Boolean, true if the data in each slot is to be interpreted as a signed integer; false if it has to
be interpreted as an unsigned integer.
@end table
@end deftp


@deftp {Object Type} cc-float-bytevector
@deftpx {Parent Type} cc-bytevector
Base type of bytevector objects holding C language floating--point values in their slots.  Objects
of this type are correctly garbage collected.
@end deftp

@c ------------------------------------------------------------------------

@deftp {Object Type} cc-bytevector-u8
@deftpx {Parent Type} cc-integer-bytevector
Type of bytevector objects holding C language integer of type @code{uint8_t} in their slots.
Objects of this type are correctly garbage collected.
@end deftp


@deftp {Object Type} cc-bytevector-s8
@deftpx {Parent Type} cc-integer-bytevector
Type of bytevector objects holding C language integer of type @code{int8_t} in their slots.  Objects
of this type are correctly garbage collected.
@end deftp

@c ------------------------------------------------------------------------

@deftp {Object Type} cc-bytevector-u16
@deftpx {Parent Type} cc-integer-bytevector
Type of bytevector objects holding C language integer of type @code{uint16_t} in their slots.
Objects of this type are correctly garbage collected.
@end deftp


@deftp {Object Type} cc-bytevector-s16
@deftpx {Parent Type} cc-integer-bytevector
Type of bytevector objects holding C language integer of type @code{int16_t} in their slots.
Objects of this type are correctly garbage collected.
@end deftp

@c ------------------------------------------------------------------------

@deftp {Object Type} cc-bytevector-u32
@deftpx {Parent Type} cc-integer-bytevector
Type of bytevector objects holding C language integer of type @code{uint32_t} in their slots.
Objects of this type are correctly garbage collected.
@end deftp


@deftp {Object Type} cc-bytevector-s32
@deftpx {Parent Type} cc-integer-bytevector
Type of bytevector objects holding C language integer of type @code{int32_t} in their slots.
Objects of this type are correctly garbage collected.
@end deftp

@c ------------------------------------------------------------------------

@deftp {Object Type} cc-bytevector-u64
@deftpx {Parent Type} cc-integer-bytevector
Type of bytevector objects holding C language integer of type @code{uint64_t} in their slots.
Objects of this type are correctly garbage collected.
@end deftp


@deftp {Object Type} cc-bytevector-s64
@deftpx {Parent Type} cc-integer-bytevector
Type of bytevector objects holding C language integer of type @code{int64_t} in their slots.
Objects of this type are correctly garbage collected.
@end deftp

@c ------------------------------------------------------------------------

@deftp {Object Type} cc-bytevector-float
@deftpx {Parent Type} cc-float-bytevector
Type of bytevector objects holding C language values of type @code{float} in their slots.  Objects
of this type are correctly garbage collected.
@end deftp


@deftp {Object Type} cc-bytevector-double
@deftpx {Parent Type} cc-float-bytevector
Type of bytevector objects holding C language values of type @code{double} in their slots.  Objects
of this type are correctly garbage collected.
@end deftp


@deftp {Object Type} cc-bytevector-long-double
@deftpx {Parent Type} cc-float-bytevector
Type of bytevector objects holding C language values of type @code{long double} in their slots.
Objects of this type are correctly garbage collected.
@end deftp

@c page
@node bytevectors pred
@section Type predicates


@defun cc-bytevector-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{cc-bytevector}; otherwise return false.
@end defun


@defun cc-integer-bytevector-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{cc-integer-bytevector}; otherwise return false.
@end defun


@defun cc-float-bytevector-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{cc-float-bytevector}; otherwise return false.
@end defun

@c ------------------------------------------------------------------------

@defun cc-bytevector-u8-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{cc-bytevector-u8}; otherwise return false.
@end defun


@defun cc-bytevector-s8-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{cc-bytevector-s8}; otherwise return false.
@end defun

@c ------------------------------------------------------------------------

@defun cc-bytevector-u16-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{cc-bytevector-u16}; otherwise return false.
@end defun


@defun cc-bytevector-s16-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{cc-bytevector-s16}; otherwise return false.
@end defun

@c ------------------------------------------------------------------------

@defun cc-bytevector-u32-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{cc-bytevector-u32}; otherwise return false.
@end defun


@defun cc-bytevector-s32-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{cc-bytevector-s32}; otherwise return false.
@end defun

@c ------------------------------------------------------------------------

@defun cc-bytevector-u64-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{cc-bytevector-u64}; otherwise return false.
@end defun


@defun cc-bytevector-s64-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{cc-bytevector-s64}; otherwise return false.
@end defun

@c ------------------------------------------------------------------------

@defun cc-bytevector-float-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{cc-bytevector-float}; otherwise return false.
@end defun


@defun cc-bytevector-double-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{cc-bytevector-double}; otherwise return false.
@end defun


@defun cc-bytevector-long-double-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{cc-bytevector-long-double}; otherwise return
false.
@end defun

@c page
@node bytevectors getters
@section Bytevector getters


@deffn {Generic Function} cc-bytevector-ref (@var{BV} @var{IDX})
Extract the value at index @var{IDX} from the bytevector @var{BV}.
@end deffn


@deffn {Method} cc-bytevector-ref ((@var{BV} cc-bytevector-u8) (@var{IDX} cc-usize))
Extract an @code{uint8_t} value from a bytevector and wrap it into a @objtype{cc-uint8} object.
@end deffn


@deffn {Method} cc-bytevector-ref ((@var{BV} cc-bytevector-s8) (@var{IDX} cc-usize))
Extract an @code{int8_t} value from a bytevector and wrap it into a @objtype{cc-sint8} object.
@end deffn


@deffn {Method} cc-bytevector-ref ((@var{BV} cc-bytevector-u16) (@var{IDX} cc-usize))
Extract an @code{uint16_t} value from a bytevector and wrap it into a @objtype{cc-uin1t16} object.
@end deffn


@deffn {Method} cc-bytevector-ref ((@var{BV} cc-bytevector-s16) (@var{IDX} cc-usize))
Extract an @code{int16_t} value from a bytevector and wrap it into a @objtype{cc-sint16} object.
@end deffn


@deffn {Method} cc-bytevector-ref ((@var{BV} cc-bytevector-u32) (@var{IDX} cc-usize))
Extract an @code{uint32_t} value from a bytevector and wrap it into a @objtype{cc-uint32} object.
@end deffn


@deffn {Method} cc-bytevector-ref ((@var{BV} cc-bytevector-s32) (@var{IDX} cc-usize))
Extract an @code{int32_t} value from a bytevector and wrap it into a @objtype{cc-sint32} object.
@end deffn


@deffn {Method} cc-bytevector-ref ((@var{BV} cc-bytevector-u64) (@var{IDX} cc-usize))
Extract an @code{uint64_t} value from a bytevector and wrap it into a @objtype{cc-uint64} object.
@end deffn


@deffn {Method} cc-bytevector-ref ((@var{BV} cc-bytevector-s64) (@var{IDX} cc-usize))
Extract an @code{int64_t} value from a bytevector and wrap it into a @objtype{cc-sint64} object.
@end deffn

@c page
@node bytevectors setters
@section Bytevector setters


@deffn {Generic Function} cc-bytevector-set! (bv idx val)
Store the value @var{VAL} into the bytevector @var{BV} at index @var{idx}.
@end deffn


@deffn {Method} cc-bytevector-set! ((@var{BV} cc-bytevector-u8) (@var{IDX} cc-usize) (@var{VAL} cc-uint8))
Store the value @var{VAL} of type @code{uint8_t} into the bytevector @var{BV} at index @var{IDX}.
@end deffn


@deffn {Method} cc-bytevector-set! ((@var{BV} cc-bytevector-s8) (@var{IDX} cc-usize) (@var{VAL} cc-sint8))
Store the value @var{VAL} of type @code{int8_t} into the bytevector @var{BV} at index @var{IDX}.
@end deffn


@deffn {Method} cc-bytevector-set! ((@var{BV} cc-bytevector-u16) (@var{IDX} cc-usize) (@var{VAL} cc-uint16))
Store the value @var{VAL} of type @code{uint16_t} into the bytevector @var{BV} at index @var{IDX}.
@end deffn


@deffn {Method} cc-bytevector-set! ((@var{BV} cc-bytevector-s16) (@var{IDX} cc-usize) (@var{VAL} cc-sint16))
Store the value @var{VAL} of type @code{int16_t} into the bytevector @var{BV} at index @var{IDX}.
@end deffn


@deffn {Method} cc-bytevector-set! ((@var{BV} cc-bytevector-u32) (@var{IDX} cc-usize) (@var{VAL} cc-uint32))
Store the value @var{VAL} of type @code{uint32_t} into the bytevector @var{BV} at index @var{IDX}.
@end deffn


@deffn {Method} cc-bytevector-set! ((@var{BV} cc-bytevector-s32) (@var{IDX} cc-usize) (@var{VAL} cc-sint32))
Store the value @var{VAL} of type @code{int32_t} into the bytevector @var{BV} at index @var{IDX}.
@end deffn


@deffn {Method} cc-bytevector-set! ((@var{BV} cc-bytevector-u64) (@var{IDX} cc-usize) (@var{VAL} cc-uint64))
Store the value @var{VAL} of type @code{uint64_t} into the bytevector @var{BV} at index @var{IDX}.
@end deffn


@deffn {Method} cc-bytevector-set! ((@var{BV} cc-bytevector-s64) (@var{IDX} cc-usize) (@var{VAL} cc-sint64))
Store the value @var{VAL} of type @code{int64_t} into the bytevector @var{BV} at index @var{IDX}.
@end deffn

@c page
@node errors
@chapter How errors are signalled


Occasionally the functions in @value{PACKAGE} signal an error; the following error symbols are
defined.


@defvr {Error Symbol} mmux-core-error
The base type of all the error symbols.
@end defvr


@defvr {Error Symbol} mmux-core-no-memory-error
@defvrx {Parent Error Symbol} mmux-core-error
Used to signal that there was not enough memory to allocate an object.
@end defvr


@defvr {Error Symbol} mmux-core-index-out-of-range
@defvrx {Parent Error Symbol} mmux-core-error
Used to signal an attempt to access the internal represenation of an object with an index out of
range.
@end defvr


@defvr {Error Symbol} mmux-core-bytevector-index-out-of-range
@defvrx {Parent Error Symbol} mmux-core-index-out-of-range
Attempt to access the internal represenation of a bytevector object with an index out of range.
@end defvr


@defvr {Error Symbol} mmux-core-instantiating-abstract-type
@defvrx {Parent Error Symbol} mmux-core-error
An attempt was performed to instantiate an abstract data type.
@end defvr

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

We can found informations and examples about Emacs modules at the repository mirror, under the
@file{modules} directory:

@center @url{https://github.com/emacs-mirror/emacs}

There is also a list of resources about Emacs modules:

@center @url{https://github.com/emacs-pe/emacs-modules}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

