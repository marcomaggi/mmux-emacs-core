\input texinfo.tex
@c %**start of header
@setfilename mmux-emacs-core.info
@settitle MMUX Emacs Core
@c %**end of header

@include version.texi
@include macros.texi
@include elisp-macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      @mmux{} Emacs Core

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    @mmux{} Emacs Core

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmux-emacs-core

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2020

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              MMUX_EMACS_CORE
@set PackagePkgconfigModule             @code{mmux-emacs-core}
@set PackageLibsVar                     @env{MMUX_EMACS_CORE_LIBS}
@set PackageCflagsVar                   @env{MMUX_EMACS_CORE_CFLAGS}

@set PackageLibstem                     @file{mmux-emacs-core}
@set PackageSharedLibraryBasename       @file{libmmux-emacs-core}

@set PackageEmacsModule                 @file{mmec}
@set PackageHeader                      mmux-emacs-core.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set PackageApiCPrefixLower             mmec_
@set PackageApiCPrefixUpper             MMEC_
@set PackageApiElispPrefix              mmec-

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@set RequiredEmacsVersion       26+

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------


@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This package installs a @gnu{} Emacs module, written in Emacs Lisp, on top of a C11 language library
implementing an Emacs dynamic module; these modules provide basic infrastructure to write dynamic
modules for Emacs, especially interfaces to foreign C language libraries.

This package supports @posix{} platforms.  This package is meant to work with @gnu{} Emacs version
@value{RequiredEmacsVersion}.  This package depends upon the external packages: @code{cl-lib}. To
run the test suite: this package requires the @code{ert} package.

This package is distributed under the terms of the @gnu{} General Public License (@gpl{}).

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}@*

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmux-emacs-core: (mmux-emacs-core).  MMUX Emacs Core a core library.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* constants::                   Constant values.
* ctypes::                      Object wrappers for C language types.
* bytevec::                     Bytevector objects.
* errors::                      How errors are signalled.
* capi::                        C language programming interface.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

External documents

* modules: (elisp)Writing Dynamic Modules.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}; this package installs a @gnu{}
Emacs module, written in Emacs Lisp, on top of a C11 language library implementing an Emacs dynamic
module; these modules provide basic infrastructure to write dynamic modules for Emacs, especially
interfaces to foreign C language libraries.

This package supports @posix{} platforms.  This package is meant to work with @gnu{} Emacs version
@value{RequiredEmacsVersion}.  This package depends upon the external packages: @code{cl-lib}.  To
run the test suite: this package requires the @code{ert} package.

@value{PACKAGE} installs various elisp modules, the main one being @value{PackageEmacsModule}; it
also installs a C language shared library with basename @value{PackageSharedLibraryBasename} (using
the @gnu{} Libtool infrastructure).  All the elisp definition names are prefixed with
@code{@value{PackageApiElispPrefix}}.  The C language shared library is installed under
@samp{$libdir}, for example:

@center @file{/usr/local/lib64}

@noindent
while the elisp module goes under @samp{$lispdir}, for example:

@center @file{/usr/local/share/emacs/site-lisp}

@noindent
so to load the module (under an Emacs installation with dynamic modules enabled) we should do
something like:

@lisp
(add-to-list 'load-path "/usr/local/lib64"
                        "/usr/local/share/emacs/site-lisp")
(require 'mmec)
@end lisp

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
It might be possible that we want to write a C language library making use of the facilities of this
package; so @value{PACKAGE} installs the single header file @value{PackageHeaderFile}.  All the C
language function names in the @api{} are prefixed with @code{@value{PackageApiCPrefixLower}}; all
the C language preprocessor symbol names are prefixed with @code{@value{PackageApiCPrefixUpper}};
all the type names are prefixed with @code{@value{PackageApiCPrefixLower}} and suffixed with
@code{_t}.

@menu
* overview linking::            Linking code with the library.
@end menu

@include overview-linking.texi

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@defun mmec-version-string
Return a string representing the interface version number.
@end defun


@defun mmec-version-interface-current
Return an integer representing the library interface current number.
@end defun


@defun mmec-version-interface-revision
Return an integer representing the library interface current revision number.
@end defun


@defun mmec-version-interface-age
Return an integer representing the library interface current age.
@end defun

@c page
@node constants
@chapter Constant values


@menu
* constants sizeof::            Size of common C language types.
* constants limits::            Ranges representable by C language types.
* constants float::             Constants related to floating-point numbers.
@end menu

@c page
@node constants sizeof
@section Size of common C language types


@deftypevr {Constant} integer mmec-SIZEOF_CHAR
@deftypevrx {Constant} integer mmec-sizeof-char
Value of type @objtype{integer} representing the size of @code{char} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_SIGNED_CHAR
@deftypevrx {Constant} integer mmec-sizeof-schar
Value of type @objtype{integer} representing the size of @code{signed char} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UNSIGNED_CHAR
@deftypevrx {Constant} integer mmec-sizeof-uchar
Value of type @objtype{integer} representing the size of @code{unsigned char} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_WCHAR_T
@deftypevrx {Constant} integer mmec-sizeof-wchar
Value of type @objtype{integer} representing the size of @code{wchar_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_SIGNED_SHORT_INT
@deftypevrx {Constant} integer mmec-sizeof-sshrt
Value of type @objtype{integer} representing the size of @code{signed short int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UNSIGNED_SHORT_INT
@deftypevrx {Constant} integer mmec-sizeof-ushrt
Value of type @objtype{integer} representing the size of @code{unsigned short int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_SIGNED_INT
@deftypevrx {Constant} integer mmec-sizeof-sint
Value of type @objtype{integer} representing the size of @code{signed int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UNSIGNED_INT
@deftypevrx {Constant} integer mmec-sizeof-uint
Value of type @objtype{integer} representing the size of @code{unsigned int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_SIGNED_LONG_INT
@deftypevrx {Constant} integer mmec-sizeof-slong
Value of type @objtype{integer} representing the size of @code{signed long int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UNSIGNED_LONG_INT
@deftypevrx {Constant} integer mmec-sizeof-ulong
Value of type @objtype{integer} representing the size of @code{unsigned long int} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_SIGNED_LONG_LONG_INT
@deftypevrx {Constant} integer mmec-sizeof-sllong
Value of type @objtype{integer} representing the size of @code{signed long long int} measured in
bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UNSIGNED_LONG_LONG_INT
@deftypevrx {Constant} integer mmec-sizeof-ullong
Value of type @objtype{integer} representing the size of @code{unsigned long long int} measured in
bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_SSIZE_T
@deftypevrx {Constant} integer mmec-sizeof-ssize
Value of type @objtype{integer} representing the size of @code{ssize_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_SIZE_T
@deftypevrx {Constant} integer mmec-sizeof-usize
Value of type @objtype{integer} representing the size of @code{size_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_INTMAX_T
@deftypevrx {Constant} integer mmec-sizeof-sintmax
Value of type @objtype{integer} representing the size of @code{intmax_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UINTMAX_T
@deftypevrx {Constant} integer mmec-sizeof-uintmax
Value of type @objtype{integer} representing the size of @code{uintmax_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_PTRDIFF_T
@deftypevrx {Constant} integer mmec-sizeof-ptrdiff
Value of type @objtype{integer} representing the size of @code{ptrdiff_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_INT8_T
@deftypevrx {Constant} integer mmec-sizeof-sint8
Value of type @objtype{integer} representing the size of @code{int8_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UINT8_T
@deftypevrx {Constant} integer mmec-sizeof-uint8
Value of type @objtype{integer} representing the size of @code{uint8_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_INT16_T
@deftypevrx {Constant} integer mmec-sizeof-sint16
Value of type @objtype{integer} representing the size of @code{int16_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UINT16_T
@deftypevrx {Constant} integer mmec-sizeof-uint16
Value of type @objtype{integer} representing the size of @code{uint16_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_INT32_T
@deftypevrx {Constant} integer mmec-sizeof-sint32
Value of type @objtype{integer} representing the size of @code{int32_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UINT32_T
@deftypevrx {Constant} integer mmec-sizeof-uint32
Value of type @objtype{integer} representing the size of @code{uint32_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_INT64_T
@deftypevrx {Constant} integer mmec-sizeof-sint64
Value of type @objtype{integer} representing the size of @code{int64_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_UINT64_T
@deftypevrx {Constant} integer mmec-sizeof-uint64
Value of type @objtype{integer} representing the size of @code{uint64_t} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_FLOAT
@deftypevrx {Constant} integer mmec-sizeof-float
Value of type @objtype{integer} representing the size of @code{float} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_DOUBLE
@deftypevrx {Constant} integer mmec-sizeof-double
Value of type @objtype{integer} representing the size of @code{double} measured in bytes.
@end deftypevr


@deftypevr {Constant} integer mmec-SIZEOF_LONG_DOUBLE
@deftypevrx {Constant} integer mmec-sizeof-ldouble
Value of type @objtype{integer} representing the size of @code{long double} measured in bytes.
@end deftypevr

@c page
@node constants limits
@section Ranges representable by C language types


@deftypevr {Constant} mmec-char mmec-CHAR_MIN
@deftypevrx {Constant} mmec-char mmec-char-min
Value of type @objtype{mmec-char} representing the minimum value in the range of by a @code{char}.
@end deftypevr


@deftypevr {Constant} mmec-char mmec-CHAR_MAX
@deftypevrx {Constant} mmec-char mmec-char-max
Value of type @objtype{mmec-char} representing the maximum value in the range of by a @code{char}.
@end deftypevr


@deftypevr {Constant} mmec-schar mmec-SCHAR_MIN
@deftypevrx {Constant} mmec-schar mmec-schar-min
Value of type @objtype{mmec-schar} representing the minimum value in the range of by a @code{signed
char}.
@end deftypevr


@deftypevr {Constant} mmec-schar mmec-SCHAR_MAX
@deftypevrx {Constant} mmec-schar mmec-schar-max
Value of type @objtype{mmec-schar} representing the maximum value in the range of by a @code{signed
char}.
@end deftypevr


@deftypevr {Constant} mmec-uchar mmec-UCHAR_MIN
@deftypevrx {Constant} mmec-uchar mmec-uchar-min
Value of type @objtype{mmec-uchar} representing the minimum value in the range of by a @code{unsigned
char}.
@end deftypevr


@deftypevr {Constant} mmec-uchar mmec-UCHAR_MAX
@deftypevrx {Constant} mmec-uchar mmec-uchar-max
Value of type @objtype{mmec-uchar} representing the maximum value in the range of by a @code{unsigned
char}.
@end deftypevr


@deftypevr {Constant} mmec-sshrt mmec-SHRT_MIN
@deftypevrx {Constant} mmec-sshrt mmec-sshrt-min
Value of type @objtype{mmec-sshrt} representing the minimum value in the range of by a @code{signed
short int}.
@end deftypevr


@deftypevr {Constant} mmec-sshrt mmec-SHRT_MAX
@deftypevrx {Constant} mmec-sshrt mmec-sshrt-max
Value of type @objtype{mmec-sshrt} representing the maximum value in the range of by a @code{signed
short int}.
@end deftypevr


@deftypevr {Constant} mmec-ushrt mmec-USHRT_MIN
@deftypevrx {Constant} mmec-ushrt mmec-ushrt-min
Value of type @objtype{mmec-ushrt} representing the minimum value in the range of by a @code{unsigned
short int}.
@end deftypevr


@deftypevr {Constant} mmec-ushrt mmec-USHRT_MAX
@deftypevrx {Constant} mmec-ushrt mmec-ushrt-max
Value of type @objtype{mmec-ushrt} representing the maximum value in the range of by a @code{unsigned
short int}.
@end deftypevr


@deftypevr {Constant} mmec-sint mmec-INT_MIN
@deftypevrx {Constant} mmec-sint mmec-sint-min
Value of type @objtype{mmec-sint} representing the minimum value in the range of by a @code{signed
int}.
@end deftypevr


@deftypevr {Constant} mmec-sint mmec-INT_MAX
@deftypevrx {Constant} mmec-sint mmec-sint-max
Value of type @objtype{mmec-sint} representing the maximum value in the range of by a @code{signed
int}.
@end deftypevr


@deftypevr {Constant} mmec-uint mmec-UINT_MIN
@deftypevrx {Constant} mmec-uint mmec-uint-min
Value of type @objtype{mmec-uint} representing the minimum value in the range of by a @code{unsigned
int}.
@end deftypevr


@deftypevr {Constant} mmec-uint mmec-UINT_MAX
@deftypevrx {Constant} mmec-uint mmec-uint-max
Value of type @objtype{mmec-uint} representing the maximum value in the range of by a @code{unsigned
int}.
@end deftypevr


@deftypevr {Constant} mmec-slong mmec-LONG_MIN
@deftypevrx {Constant} mmec-slong mmec-slong-min
Value of type @objtype{mmec-slong} representing the minimum value in the range of by a @code{signed
long int}.
@end deftypevr


@deftypevr {Constant} mmec-slong mmec-LONG_MAX
@deftypevrx {Constant} mmec-slong mmec-slong-max
Value of type @objtype{mmec-slong} representing the maximum value in the range of by a @code{signed
long int}.
@end deftypevr


@deftypevr {Constant} mmec-ulong mmec-ULONG_MIN
@deftypevrx {Constant} mmec-ulong mmec-ulong-min
Value of type @objtype{mmec-ulong} representing the minimum value in the range of by a @code{unsigned
long int}.
@end deftypevr


@deftypevr {Constant} mmec-ulong mmec-ULONG_MAX
@deftypevrx {Constant} mmec-ulong mmec-ulong-max
Value of type @objtype{mmec-ulong} representing the maximum value in the range of by a @code{unsigned
long int}.
@end deftypevr


@deftypevr {Constant} mmec-sllong mmec-LLONG_MIN
@deftypevrx {Constant} mmec-sllong mmec-sllong-min
Value of type @objtype{mmec-sllong} representing the minimum value in the range of by a @code{signed
long long int}.
@end deftypevr


@deftypevr {Constant} mmec-sllong mmec-LLONG_MAX
@deftypevrx {Constant} mmec-sllong mmec-sllong-max
Value of type @objtype{mmec-sllong} representing the maximum value in the range of by a @code{signed
long long int}.
@end deftypevr


@deftypevr {Constant} mmec-ullong mmec-ULLONG_MIN
@deftypevrx {Constant} mmec-ullong mmec-ullong-min
Value of type @objtype{mmec-ullong} representing the minimum value in the range of by a @code{unsigned
long long int}.
@end deftypevr


@deftypevr {Constant} mmec-ullong mmec-ULLONG_MAX
@deftypevrx {Constant} mmec-ullong mmec-ullong-max
Value of type @objtype{mmec-ullong} representing the maximum value in the range of by a @code{unsigned
long long int}.
@end deftypevr


@deftypevr {Constant} mmec-wchar mmec-WCHAR_MIN
@deftypevrx {Constant} mmec-wchar mmec-wchar-min
Value of type @objtype{mmec-wchar} representing the minimum value in the range of by a @code{wchar_t}.
@end deftypevr


@deftypevr {Constant} mmec-wchar mmec-WCHAR_MAX
@deftypevrx {Constant} mmec-wchar mmec-wchar-max
Value of type @objtype{mmec-wchar} representing the maximum value in the range of by a @code{wchar_t}.
Valuex of type @objtype{mmec-wchar} representing the maximum value in the range of by a @code{wchar-t}.
@end deftypevr


@deftypevr {Constant} mmec-ssize mmec-SSIZE_T_MIN
@deftypevrx {Constant} mmec-ssize mmec-ssize-min
Value of type @objtype{mmec-ssize} representing the minimum value in the range of by a @code{ssize_t}.
@end deftypevr


@deftypevr {Constant} mmec-ssize mmec-SSIZE_T_MAX
@deftypevrx {Constant} mmec-ssize mmec-ssize-max
Value of type @objtype{mmec-ssize} representing the maximum value in the range of by a @code{ssize_t}.
@end deftypevr


@deftypevr {Constant} mmec-ptrdiff mmec-PTRDIFF_T_MIN
@deftypevrx {Constant} mmec-ptrdiff mmec-ptrdiff-min
Value of type @objtype{mmec-ptrdiff} representing the minimum value in the range of by a
@code{ptrdiff_t}.
@end deftypevr


@deftypevr {Constant} mmec-ptrdiff mmec-PTRDIFF_T_MAX
@deftypevrx {Constant} mmec-ptrdiff mmec-ptrdiff-max
Value of type @objtype{mmec-ptrdiff} representing the maximum value in the range of by a
@code{ptrdiff_t}.
@end deftypevr


@deftypevr {Constant} mmec-usize mmec-SIZE_T_MIN
@deftypevrx {Constant} mmec-usize mmec-usize-min
Value of type @objtype{mmec-usize} representing the minimum value in the range of by a @code{size_t}.
@end deftypevr


@deftypevr {Constant} mmec-usize mmec-SIZE_T_MAX
@deftypevrx {Constant} mmec-usize mmec-usize-max
Value of type @objtype{mmec-usize} representing the maximum value in the range of by a @code{size_t}.
@end deftypevr


@deftypevr {Constant} mmec-sintmax mmec-INTMAX_MIN
@deftypevrx {Constant} mmec-sintmax mmec-sintmax-min
Value of type @objtype{mmec-sintmax} representing the minimum value in the range of by a
@code{intmax_t}.
@end deftypevr


@deftypevr {Constant} mmec-sintmax mmec-INTMAX_MAX
@deftypevrx {Constant} mmec-sintmax mmec-sintmax-max
Value of type @objtype{mmec-sintmax} representing the maximum value in the range of by a
@code{intmax_t}.
@end deftypevr


@deftypevr {Constant} mmec-uintmax mmec-UINTMAX_MIN
@deftypevrx {Constant} mmec-uintmax mmec-uintmax-min
Value of type @objtype{mmec-uintmax} representing the minimum value in the range of by a
@code{uintmax_t}.
@end deftypevr


@deftypevr {Constant} mmec-uintmax mmec-UINTMAX_MAX
@deftypevrx {Constant} mmec-uintmax mmec-uintmax-max
Value of type @objtype{mmec-uintmax} representing the maximum value in the range of by a
@code{uintmax_t}.
@end deftypevr


@deftypevr {Constant} mmec-sint8 mmec-INT8_MIN
@deftypevrx {Constant} mmec-sint8 mmec-sint8-min
Value of type @objtype{mmec-sint8} representing the minimum value in the range of by a @code{int8_t}.
@end deftypevr


@deftypevr {Constant} mmec-sint8 mmec-INT8_MAX
@deftypevrx {Constant} mmec-sint8 mmec-sint8-max
Value of type @objtype{mmec-sint8} representing the maximum value in the range of by a @code{int8_t}.
@end deftypevr


@deftypevr {Constant} mmec-uint8 mmec-UINT8_MIN
@deftypevrx {Constant} mmec-uint8 mmec-uint8-min
Value of type @objtype{mmec-uint8} representing the minimum value in the range of by a @code{uint8_t}.
@end deftypevr


@deftypevr {Constant} mmec-uint8 mmec-UINT8_MAX
@deftypevrx {Constant} mmec-uint8 mmec-uint8-max
Value of type @objtype{mmec-uint8} representing the maximum value in the range of by a @code{uint8_t}.
@end deftypevr


@deftypevr {Constant} mmec-sint16 mmec-INT16_MIN
@deftypevrx {Constant} mmec-sint16 mmec-sint16-min
Value of type @objtype{mmec-sint16} representing the minimum value in the range of by a
@code{int16_t}.
@end deftypevr


@deftypevr {Constant} mmec-sint16 mmec-INT16_MAX
@deftypevrx {Constant} mmec-sint16 mmec-sint16-max
Value of type @objtype{mmec-sint16} representing the maximum value in the range of by a
@code{int16_t}.
@end deftypevr


@deftypevr {Constant} mmec-uint16 mmec-UINT16_MIN
@deftypevrx {Constant} mmec-uint16 mmec-uint16-min
Value of type @objtype{mmec-uint16} representing the minimum value in the range of by a
@code{uint16_t}.
@end deftypevr


@deftypevr {Constant} mmec-uint16 mmec-UINT16_MAX
@deftypevrx {Constant} mmec-uint16 mmec-uint16-max
Value of type @objtype{mmec-uint16} representing the maximum value in the range of by a
@code{uint16_t}.
@end deftypevr


@deftypevr {Constant} mmec-sint32 mmec-INT32_MIN
@deftypevrx {Constant} mmec-sint32 mmec-int32-min
Value of type @objtype{mmec-sint32} representing the minimum value in the range of by a
@code{int32_t}.
@end deftypevr


@deftypevr {Constant} mmec-sint32 mmec-INT32_MAX
@deftypevrx {Constant} mmec-sint32 mmec-int32-max
Value of type @objtype{mmec-sint32} representing the maximum value in the range of by a
@code{int32_t}.
@end deftypevr


@deftypevr {Constant} mmec-uint32 mmec-UINT32_MIN
@deftypevrx {Constant} mmec-uint32 mmec-uint32-min
Value of type @objtype{mmec-uint32} representing the minimum value in the range of by a
@code{uint32_t}.
@end deftypevr


@deftypevr {Constant} mmec-uint32 mmec-UINT32_MAX
@deftypevrx {Constant} mmec-uint32 mmec-uint32-max
Value of type @objtype{mmec-uint32} representing the maximum value in the range of by a
@code{uint32_t}.
@end deftypevr


@deftypevr {Constant} mmec-sint64 mmec-INT64_MIN
@deftypevrx {Constant} mmec-sint64 mmec-sint64-min
Value of type @objtype{mmec-sint64} representing the minimum value in the range of by a
@code{int64_t}.
@end deftypevr


@deftypevr {Constant} mmec-sint64 mmec-INT64_MAX
@deftypevrx {Constant} mmec-sint64 mmec-sint64-max
Value of type @objtype{mmec-sint64} representing the maximum value in the range of by a
@code{int64_t}.
@end deftypevr


@deftypevr {Constant} mmec-uint64 mmec-UINT64_MIN
@deftypevrx {Constant} mmec-uint64 mmec-uint64-min
Value of type @objtype{mmec-uint64} representing the minimum value in the range of by a
@code{uint64_t}.
@end deftypevr


@deftypevr {Constant} mmec-uint64 mmec-UINT64_MAX
@deftypevrx {Constant} mmec-uint64 mmec-uint64-max
Value of type @objtype{mmec-uint64} representing the maximum value in the range of by a
@code{uint64_t}.
@end deftypevr


@deftypevr {Constant} mmec-float mmec-FLT_MIN
@deftypevrx {Constant} mmec-float mmec-float-min
Value of type @objtype{mmec-float} representing the system constant @code{FLT_MIN}.
@end deftypevr


@deftypevr {Constant} mmec-float mmec-FLT_MAX
@deftypevrx {Constant} mmec-float mmec-float-max
Value of type @objtype{mmec-float} representing the system constant @code{FLT_MAX}.
@end deftypevr


@deftypevr {Constant} mmec-double mmec-DBL_MIN
@deftypevrx {Constant} mmec-double mmec-double-min
Value of type @objtype{mmec-double} representing the system constant @code{DBL_MIN}.
@end deftypevr


@deftypevr {Constant} mmec-double mmec-DBL_MAX
@deftypevrx {Constant} mmec-double mmec-double-max
Value of type @objtype{mmec-double} representing the system constant @code{DBL_MAX}.
@end deftypevr


@deftypevr {Constant} mmec-ldouble mmec-LDBL_MIN
@deftypevrx {Constant} mmec-ldouble mmec-ldouble-min
Value of type @objtype{mmec-ldouble} representing the system constant @code{LDBL_MIN}.
@end deftypevr


@deftypevr {Constant} mmec-ldouble mmec-LDBL_MAX
@deftypevrx {Constant} mmec-ldouble mmec-ldouble-max
Value of type @objtype{mmec-ldouble} representing the system constant @code{LDBL_MAX}.
@end deftypevr

@c page
@node constants float
@section Constants related to floating--point numbers


@deftypevr {Constant} integer mmec-FLT_ROUNDS
Value of type @objtype{integer} the system constant @code{FLT_ROUNDS}.
@end deftypevr


@deftypevr {Constant} integer mmec-FLT_RADIX
Value of type @objtype{integer} representing the system constant @code{FLT_RADIX}.
@end deftypevr


@deftypevr {Constant} integer mmec-FLT_MANT_DIG
Value of type @objtype{integer} representing the system constant @code{FLT_MANT_DIG}.
@end deftypevr


@deftypevr {Constant} integer mmec-DBL_MANT_DIG
Value of type @objtype{integer} representing the system constant @code{DBL_MANT_DIG}.
@end deftypevr


@deftypevr {Constant} integer mmec-LDBL_MANT_DIG
Value of type @objtype{integer} representing the system constant @code{LDBL_MANT_DIG}.
@end deftypevr


@deftypevr {Constant} integer mmec-FLT_DIG
Value of type @objtype{integer} representing the system constant @code{FLT_DIG}.
@end deftypevr


@deftypevr {Constant} integer mmec-DBL_DIG
Value of type @objtype{integer} representing the system constant @code{DBL_DIG}.
@end deftypevr


@deftypevr {Constant} integer mmec-LDBL_DIG
Value of type @objtype{integer} representing the system constant @code{LDBL_DIG}.
@end deftypevr


@deftypevr {Constant} integer mmec-FLT_MIN_EXP
Value of type @objtype{integer} representing the system constant @code{FLT_MIN_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-DBL_MIN_EXP
Value of type @objtype{integer} representing the system constant @code{DBL_MIN_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-LDBL_MIN_EXP
Value of type @objtype{integer} representing the system constant @code{LDBL_MIN_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-FLT_MIN_10_EXP
Value of type @objtype{integer} representing the system constant @code{FLT_MIN_10_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-DBL_MIN_10_EXP
Value of type @objtype{integer} representing the system constant @code{DBL_MIN_10_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-LDBL_MIN_10_EXP
Value of type @objtype{integer} representing the system constant @code{LDBL_MIN_10_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-FLT_MAX_EXP
Value of type @objtype{integer} representing the system constant @code{FLT_MAX_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-DBL_MAX_EXP
Value of type @objtype{integer} representing the system constant @code{DBL_MAX_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-LDBL_MAX_EXP
Value of type @objtype{integer} representing the system constant @code{LDBL_MAX_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-FLT_MAX_10_EXP
Value of type @objtype{integer} representing the system constant @code{FLT_MAX_10_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-DBL_MAX_10_EXP
Value of type @objtype{integer} representing the system constant @code{DBL_MAX_10_EXP}.
@end deftypevr


@deftypevr {Constant} integer mmec-LDBL_MAX_10_EXP
Value of type @objtype{integer} representing the system constant @code{LDBL_MAX_10_EXP}.
@end deftypevr


@deftypevr {Constant} mmec-float mmec-FLT_EPSILON
Value of type @objtype{mmec-float} representing the system constant @code{FLT_EPSILON}.
@end deftypevr


@deftypevr {Constant} mmec-double mmec-DBL_EPSILON
Value of type @objtype{mmec-double} representing the system constant @code{DBL_EPSILON}.
@end deftypevr


@deftypevr {Constant} mmec-ldouble mmec-LDBL_EPSILON
Value of type @objtype{mmec-ldouble} representing the system constant @code{LDBL_EPSILON}.
@end deftypevr

@c page
@node ctypes
@chapter Object wrappers for C language types.


@value{PACKAGE} defines elisp data types in the module @value{PackageEmacsModule}.  Many wrappers
for integer types are implemented for safety of writing interfaces to C language libraries and for
better dispatching of multimethods.

@quotation
@strong{NOTE} At the time of this writing (Feb 2, 2020) @gnu{} Emacs version 26 internally
represents exact integer objects with values of type C language @code{intmax_t}, but not the whole
range of such type is available.
@end quotation

@menu
* ctypes typedefs::             Object type definitions.
* ctypes comparison::           Comparison operations.
@end menu

@c page
@node ctypes typedefs
@section Object type definitions


@menu
* ctypes typedefs base::        Base type definitions.
* ctypes typedefs char::        Wrapper for @code{char}.
* ctypes typedefs schar::       Wrapper for @code{signed char}.
* ctypes typedefs uchar::       Wrapper for @code{unsigned char}.
* ctypes typedefs wchar::       Wrapper for @code{wchar_t}.
* ctypes typedefs sshrt::       Wrapper for @code{signed short int}.
* ctypes typedefs ushrt::       Wrapper for @code{unsigned short int}.
* ctypes typedefs sint::        Wrapper for @code{signed int}.
* ctypes typedefs uint::        Wrapper for @code{unsigned int}.
* ctypes typedefs slong::       Wrapper for @code{signed long int}.
* ctypes typedefs ulong::       Wrapper for @code{unsigned long int}.
* ctypes typedefs sllong::      Wrapper for @code{signed long long int}.
* ctypes typedefs ullong::      Wrapper for @code{unsigned long long int}.
* ctypes typedefs ssize::       Wrapper for @code{ssize_t}.
* ctypes typedefs usize::       Wrapper for @code{size_t}.
* ctypes typedefs sintmax::     Wrapper for @code{intmax_t}.
* ctypes typedefs uintmax::     Wrapper for @code{uintmax_t}.
* ctypes typedefs ptrdiff::     Wrapper for @code{ptrdiff_t}.
* ctypes typedefs sint8::       Wrapper for @code{int8_t}.
* ctypes typedefs uint8::       Wrapper for @code{uint8_t}.
* ctypes typedefs sint16::      Wrapper for @code{int16_t}.
* ctypes typedefs uint16::      Wrapper for @code{uint16_t}.
* ctypes typedefs sint32::      Wrapper for @code{int32_t}.
* ctypes typedefs uint32::      Wrapper for @code{uint32_t}.
* ctypes typedefs sint64::      Wrapper for @code{int64_t}.
* ctypes typedefs uint64::      Wrapper for @code{uint64_t}.
* ctypes typedefs float::       Wrapper for @code{float}.
* ctypes typedefs double::      Wrapper for @code{double}.
* ctypes typedefs ldouble::     Wrapper for @code{long double}.
@end menu

@c ------------------------------------------------------------------------

@macro ElispNumberValueDefinition{ETYPESTEM, CTYPE, EANCESTORTYPESTEM, ENORMTYPESTEM, INTREPDESCR}
@ElispNumberValueTypeDefinition{\ETYPESTEM\, \CTYPE\, \EANCESTORTYPESTEM\, \ENORMTYPESTEM\, \INTREPDESCR\}
@ElispNumberValueDefaultMethods{\ETYPESTEM\, \CTYPE\, \EANCESTORTYPESTEM\, \ENORMTYPESTEM\, \INTREPDESCR\}
@ElispNumberValueSpecialisedMethods{\ETYPESTEM\, \CTYPE\, \EANCESTORTYPESTEM\, \ENORMTYPESTEM\, \INTREPDESCR\}
@ElispNumberValueFitsFunctions{\ETYPESTEM\, \CTYPE\, \EANCESTORTYPESTEM\, \ENORMTYPESTEM\, \INTREPDESCR\}
@end macro

@c ------------------------------------------------------------------------

@macro ElispNumberValueTypeDefinition{ETYPESTEM, CTYPE, EANCESTORTYPESTEM, ENORMTYPESTEM, INTREPDESCR}
@deftp {Object Type} mmec-\ETYPESTEM\
@deftpx {Parent Type} mmec-\EANCESTORTYPESTEM\
Object wrapper for the C language type @code{\CTYPE\}.
@end deftp


@defun mmec-\ETYPESTEM\-p @var{obj}
Return true if @var{obj} is an instance of @objtype{mmec-\ETYPESTEM\}, otherwise return false.
@end defun


@defun mmec-\ETYPESTEM\-obj @var{OBJ}
Given an instance of @objtype{mmec-\ETYPESTEM\}: return its internal representation as
\INTREPDESCR\.
@end defun

@end macro

@c ------------------------------------------------------------------------

@macro ElispNumberValueDefaultMethods{ETYPESTEM, CTYPE, EANCESTORTYPESTEM, ENORMTYPESTEM, INTREPDESCR}
@deffn {Generic Function} mmec-\ETYPESTEM\ @var{INIT}
Constructor for number of objects of type @objtype{mmec-\ETYPESTEM\}.  The argument @var{INIT} must be a
number value.
@end deffn


@deffn {Method} mmec-\ETYPESTEM\ (@var{INIT} mmec-\ETYPESTEM\)
This is the copy constructor implemented as method.  This method creates a duplicate of the
@var{INIT} value, but it reuses the internal representation (which is immutable).
@end deffn


@deffn {Method} cl-print-object (@var{OBJ} mmec-\ETYPESTEM\) @var{STREAM}
@cindex @func{cl-prin1}, printing @objtype{mmec-\ETYPESTEM\} to a stream
@cindex @func{cl-prin1-to-string}, printing @objtype{mmec-\ETYPESTEM\} to a string
Specialised method that prints a representation of @var{OBJ} to @var{STREAM}.  We can print
instances of @objtype{mmec-\ETYPESTEM\} with the generic functions @func{cl-prin1} and
@func{cl-prin1-to-string}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro ElispNumberValueSpecialisedMethods{ETYPESTEM, CTYPE, EANCESTORTYPESTEM, ENORMTYPESTEM, INTREPDESCR}
@deffn {Method} mmec-\ETYPESTEM\ (@var{INIT} integer)
Specialised constructor for number values of type @objtype{mmec-\ETYPESTEM\}.

This constructor normalises the initialisation argument to an object of type @objtype{mmec-\ENORMTYPESTEM\},
then it checks if the range is valid: if it is is builds an object of type @objtype{mmec-\ETYPESTEM\},
otherwise it raises the error condition @code{mmec-error-value-out-of-range}.
@end deffn


@deffn {Method} mmec-\ETYPESTEM\ (@var{INIT} float)
Specialised constructor for number values of type @objtype{mmec-\ETYPESTEM\}.

This constructor normalises the initialisation argument to an object of type @objtype{mmec-\ENORMTYPESTEM\},
then it checks if the range is valid: if it is is builds an object of type @objtype{mmec-\ETYPESTEM\},
otherwise it raises the error condition @code{mmec-error-value-out-of-range}.
@end deffn


@deffn {Method} mmec-\ETYPESTEM\ (@var{INIT} mmec-\EANCESTORTYPESTEM\)
Specialised constructor for number values of type @objtype{mmec-\ETYPESTEM\}.

This constructor normalises the initialisation argument to an object of type @objtype{mmec-\ENORMTYPESTEM\},
then it checks if the range is valid: if it is is builds an object of type @objtype{mmec-\ETYPESTEM\},
otherwise it raises the error condition @code{mmec-error-value-out-of-range}.
@end deffn


@deffn {Method} mmec-\ETYPESTEM\ (@var{INIT} mmec-number)
Specialised constructor for number values of type @objtype{mmec-\ETYPESTEM\}.

This constructor signals that the given initialisation argument is invalid by raising the condition
@code{mmec-error-unsupported-init-type}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro ElispNumberValueFitsFunctions{ETYPESTEM, CTYPE, EANCESTORTYPESTEM, ENORMTYPESTEM, INTREPDESCR}
@deffn {Generic Function} mmec-fits-\ETYPESTEM\-p @var{INIT}
Generic function that returns true if the argument @var{INIT} would fit a representation as
@objtype{mmec-\ETYPESTEM\}; otherwise it returns false.  The argument @var{INIT} must be a number
value.
@end deffn


@deffn {Method} mmec-fits-\ETYPESTEM\-p (@var{INIT} mmec-\EANCESTORTYPESTEM\)
@deffnx {Method} mmec-fits-\ETYPESTEM\-p (@var{INIT} integer)
@deffnx {Method} mmec-fits-\ETYPESTEM\-p (@var{INIT} float)
Specialised method that converts @var{INIT} into a value of type @objtype{mmec-\ENORMTYPESTEM\},
then returns true if the converted value would fit a representation as @objtype{mmec-\ETYPESTEM\};
otherwise it returns false.
@end deffn

@end macro

@c page
@node ctypes typedefs base
@subsection Base type definitions


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.  All the
following types are to be considered ``abstract'', so we must not instantiate them.


@deftp {Abstract Object Type} mmec-number
Base type of all the custom number types defined by this module.
@end deftp


@deftp {Abstract Object Type} mmec-integer
@deftpx {Parent Type} mmec-number
Base type of all the custom exact integer number types defined by this module.
@end deftp


@deftp {Abstract Object Type} mmec-signed-integer
@deftpx {Parent Type} mmec-integer
Base type of all the custom exact signed integer number types defined by this module.
@end deftp


@deftp {Abstract Object Type} mmec-unsigned-integer
@deftpx {Parent Type} mmec-integer
Base type of all the custom exact unsigned integer number types defined by this module.
@end deftp


@deftp {Abstract Object Type} mmec-floating-point
@deftpx {Parent Type} mmec-number
Base type of all the custom floating--point number types defined by this module.
@end deftp


@defun mmec-number-p @var{OBJ}
@defunx mmec-integer-p @var{OBJ}
@defunx mmec-signed-integer-p @var{OBJ}
@defunx mmec-unsigned-integer-p @var{OBJ}
@defunx mmec-floating-point-p @var{OBJ}
Return true if @var{OBJ} is an instance of the specified type; otherwise return false.
@end defun

@c page
@node ctypes typedefs char
@subsection Wrapper for @code{char}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{char, char, signed-integer, sint64, Emacs built--in @code{integer} object representing its @ascii{} code}

@c page
@node ctypes typedefs schar
@subsection Wrapper for @code{signed char}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{schar, signed char, signed-integer, sint64, Emacs built--in @code{integer} object representing its @ascii{} code}

@c page
@node ctypes typedefs uchar
@subsection Wrapper for @code{unsigned char}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{uchar, unsigned char, unsigned-integer, uint64, Emacs built--in @code{integer} object representing its @ascii{} code}

@c page
@node ctypes typedefs wchar
@subsection Wrapper for @code{wchar_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{wchar, wchar_t, unsigned-integer, uint64, Emacs user--pointer object representing its code}

@c page
@node ctypes typedefs sshrt
@subsection Wrapper for @code{signed short int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{sshrt, signed short int, signed-integer, sint64, Emacs built--in @objtype{integer} value}

@c page
@node ctypes typedefs ushrt
@subsection Wrapper for @code{unsigned short int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{ushrt, unsigned short int, unsigned-integer, uint64, Emacs built--in @objtype{integer} value}

@c page
@node ctypes typedefs sint
@subsection Wrapper for @code{signed int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{sint, signed int, signed-integer, sint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs uint
@subsection Wrapper for @code{unsigned int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{uint, unsigned int, unsigned-integer, uint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs slong
@subsection Wrapper for @code{signed long int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{slong, signed long int, signed-integer, sint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs ulong
@subsection Wrapper for @code{unsigned long int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{ulong, unsigned long int, unsigned-integer, uint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs sllong
@subsection Wrapper for @code{signed long long int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{sllong, signed long long int, signed-integer, sint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs ullong
@subsection Wrapper for @code{unsigned long long int}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{ullong, unsigned long long int, unsigned-integer, uint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs ssize
@subsection Wrapper for @code{ssize_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{ssize, ssize_t, signed-integer, sint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs usize
@subsection Wrapper for @code{size_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{usize, size_t, unsigned-integer, uint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs sintmax
@subsection Wrapper for @code{intmax_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{sintmax, intmax_t, signed-integer, sint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs uintmax
@subsection Wrapper for @code{uintmax_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{uintmax, uintmax_t, unsigned-integer, uint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs ptrdiff
@subsection Wrapper for @code{ptrdiff_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{ptrdiff, ptrdiff_t, signed-integer, sint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs sint8
@subsection Wrapper for @code{int8_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{sint8, int8_t, signed-integer, sint64, Emacs built--in @objtype{integer} value}

@c page
@node ctypes typedefs uint8
@subsection Wrapper for @code{uint8_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{uint8, uint8_t, unsigned-integer, uint64, Emacs built--in @objtype{integer} value}

@c page
@node ctypes typedefs sint16
@subsection Wrapper for @code{int16_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{sint16, int16_t, signed-integer, sint64, Emacs built--in @objtype{integer} value}

@c page
@node ctypes typedefs uint16
@subsection Wrapper for @code{uint16_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{uint16, uint16_t, unsigned-integer, uint64, Emacs built--in @objtype{integer} value}

@c page
@node ctypes typedefs sint32
@subsection Wrapper for @code{int32_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{sint32, int32_t, signed-integer, sint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs uint32
@subsection Wrapper for @code{uint32_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{uint32, uint32_t, unsigned-integer, uint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs sint64
@subsection Wrapper for @code{int64_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.  The custom
number type @objtype{mmec-sint64} is special because it is used for normalised representation of all
the exact signed integer numbers, both built--in and custom.


@ElispNumberValueTypeDefinition{sint64, int64_t, signed-integer, sint64, Emacs user--pointer object representing its value}
@ElispNumberValueDefaultMethods{sint64, int64_t, signed-integer, sint64, Emacs user--pointer object representing its value}


@deffn {Method} mmec-sint64 (@var{INIT} integer)
Specialised constructor for number values of type @objtype{mmec-sint64}.

This constructor assumes that a value of type @objtype{integer} always fits into the internal
representation of a @objtype{mmec-sint64} value.
@end deffn


@deffn {Method} mmec-sint64 (@var{INIT} float)
Specialised constructor for number values of type @objtype{mmec-sint64}.

This constructor assumes that a value of type @objtype{float} always fits into the internal
representation of a @objtype{mmec-sint64} value.  The floating--point number is first rounded to
integer with the standard C language function @cfunc{round}.
@end deffn


@deffn {Method} mmec-sint64 (@var{INIT} mmec-char)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-schar)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-sshrt)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-sint)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-slong)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-sllong)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-sintmax)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-ssize)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-ptrdiff)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-sint8)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-sint16)
@deffnx {Method} mmec-sint64 (@var{INIT} mmec-sint32)
Specialised constructor for number values of type @objtype{mmec-sint64}.

This constructor normalises the internal representation of @var{INIT} to a @code{int64_t} value,
assuming that the internal representation always fits the range of @code{int64_t}.
@end deffn


@deffn {Method} mmec-sint64 (@var{INIT} mmec-number)
Specialised constructor for number values of type @objtype{mmec-sint64}.

This constructor signals that the given initialisation argument is invalid by raising the condition
@code{mmec-error-unsupported-init-type}.
@end deffn

@c ------------------------------------------------------------------------

@ElispNumberValueFitsFunctions{sint64, int64_t, signed-integer, sint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs uint64
@subsection Wrapper for @code{uint64_t}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.  The custom
number type @objtype{mmec-uint64} is special because it is used for normalised representation of all
the exact unsigned integer numbers, both built--in and custom.


@ElispNumberValueTypeDefinition{uint64, uint64_t, unsigned-integer, uint64, Emacs user--pointer object representing its value}
@ElispNumberValueDefaultMethods{uint64, uint64_t, unsigned-integer, uint64, Emacs user--pointer object representing its value}


@deffn {Method} mmec-uint64 (@var{INIT} integer)
Specialised constructor for number values of type @objtype{mmec-uint64}.

This constructor assumes that a value of type @objtype{integer} always fits into the internal
representation of a @objtype{mmec-uint64} value.  If @var{INIT} is negative: this method raises the
condition @code{mmec-error-value-out-of-range}.
@end deffn


@deffn {Method} mmec-uint64 (@var{INIT} float)
Specialised constructor for number values of type @objtype{mmec-uint64}.

This constructor assumes that a value of type @objtype{float} always fits into the internal
representation of a @objtype{mmec-uint64} value.  The floating--point number is first rounded to
integer with the standard C language function @cfunc{round}.  If @var{INIT} is negative: this method
raises the condition @code{mmec-error-value-out-of-range}.
@end deffn


@deffn {Method} mmec-uint64 (@var{INIT} mmec-uchar)
@deffnx {Method} mmec-uint64 (@var{INIT} mmec-ushrt)
@deffnx {Method} mmec-uint64 (@var{INIT} mmec-uint)
@deffnx {Method} mmec-uint64 (@var{INIT} mmec-ulong)
@deffnx {Method} mmec-uint64 (@var{INIT} mmec-ullong)
@deffnx {Method} mmec-uint64 (@var{INIT} mmec-uintmax)
@deffnx {Method} mmec-uint64 (@var{INIT} mmec-usize)
@deffnx {Method} mmec-uint64 (@var{INIT} mmec-uint8)
@deffnx {Method} mmec-uint64 (@var{INIT} mmec-uint16)
@deffnx {Method} mmec-uint64 (@var{INIT} mmec-uint32)
Specialised constructor for number values of type @objtype{mmec-uint64}.

This constructor normalises the internal representation of @var{INIT} to a @code{uint64_t} value,
assuming that the internal representation always fits the range of @code{uint64_t}.
@end deffn


@deffn {Method} mmec-uint64 (@var{INIT} mmec-number)
Specialised constructor for number values of type @objtype{mmec-uint64}.

This constructor signals that the given initialisation argument is invalid by raising the condition
@code{mmec-error-unsupported-init-type}.
@end deffn

@c ------------------------------------------------------------------------

@ElispNumberValueFitsFunctions{uint64, uint64_t, unsigned-integer, uint64, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs float
@subsection Wrapper for @code{float}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{float, float, floating-point, ldouble, Emacs user--pointer object representing its value}

@c page
@node ctypes typedefs double
@subsection Wrapper for @code{double}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.


@ElispNumberValueDefinition{double, double, floating-point, ldouble, Emacs built--in @objtype{float} value}

@c page
@node ctypes typedefs ldouble
@subsection Wrapper for @code{long double}


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.  The custom
number type @objtype{mmec-ldouble} is special because it is used for normalised representation of
all the floating--point numbers, both built--in and custom.


@ElispNumberValueTypeDefinition{ldouble, long double, floating-point, ldouble, Emacs user--pointer object representing its value}
@ElispNumberValueDefaultMethods{ldouble, long double, floating-point, ldouble, Emacs user--pointer object representing its value}


@deffn {Method} mmec-ldouble (@var{INIT} integer)
Specialised constructor for number values of type @objtype{mmec-ldouble}.

This constructor assumes that a value of type @objtype{integer} always fits into the internal
representation of a @objtype{mmec-ldouble} value.  The argument @var{INIT} is first converted to the
Emacs built--in type @objtype{float} with the function @func{float}.
@end deffn


@deffn {Method} mmec-ldouble (@var{INIT} float)
Specialised constructor for number values of type @objtype{mmec-ldouble}.

This constructor assumes that a value of type @objtype{float} always fits into the internal
representation of a @objtype{mmec-ldouble} value.
@end deffn


@deffn {Method} mmec-ldouble (@var{INIT} mmec-float)
@deffnx {Method} mmec-ldouble (@var{INIT} mmec-double)
Specialised constructor for number values of type @objtype{mmec-ldouble}.

This constructor normalises the internal representation of @var{INIT} to a @code{long double} value,
assuming that the internal representation always fits the range of @code{long double}.
@end deffn


@deffn {Method} mmec-ldouble (@var{INIT} mmec-number)
Specialised constructor for number values of type @objtype{mmec-ldouble}.

This constructor signals that the given initialisation argument is invalid by raising the condition
@code{mmec-error-unsupported-init-type}.
@end deffn

@c ------------------------------------------------------------------------

@ElispNumberValueFitsFunctions{ldouble, long double, floating-point, ldouble, Emacs user--pointer object representing its value}

@c page
@node ctypes comparison
@section Comparison operations


To perform a comparison operation among operands of different types, we normalise the operands as
follows:

@itemize
@item
We convert all the signed integers to @objtype{mmec-sint64}.

@item
We convert all the unsigned integers to @objtype{mmec-uint64}.

@item
We convert all the floating--point numbers to @objtype{mmec-ldouble}.

@item
When comparing integers and floating--point numbers we convert all the integer types to
@objtype{mmec-ldouble}.
@end itemize

@c ------------------------------------------------------------------------


@macro mmuxDefunNumericComparisonMethod{OPERATOR, TYPE1, TYPE2}
@deffn {Method} mmec-2\OPERATOR\ ((@vari{op} \TYPE1\) (@varii{op} \TYPE2\))
Return true if @vari{OP} \OPERATOR\ @varii{OP}; otherwise return false.
@end deffn

@end macro


@macro mmuxDefunNumericComparisonFunction{OPERATOR, OPERATIONDESCRIPTION}
@defun mmec\OPERATOR\ @var{OP} &rest @var{ops}
Return true if all the operands are \OPERATIONDESCRIPTION\, left to right; otherwise return false.
The comparison is performed with the generic function @func{mmec-2\OPERATOR\}.
@end defun


@deffn {Generic Function} {mmec-2\OPERATOR\} (@vari{OP} @varii{OP})
Return true if @vari{OP} \OPERATOR\ @varii{OP}; otherwise return false.
@end deffn

@c These are the methods that actually do the operation on built-in numeric objects.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, integer, integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, integer, float}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, float,   integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, float,   float}

@c These are the methods that actually do the operation on custom user-pointer objects.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-sint64, mmec-sint64}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-uint64, mmec-uint64}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-sint64, mmec-uint64}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-uint64, mmec-sint64}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-ldouble, mmec-ldouble}

@c These are the methods that normalise operands among operational types.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-sint64, mmec-ldouble}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-uint64, mmec-ldouble}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-ldouble, mmec-sint64}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-ldouble, mmec-uint64}

@c These are the methods that normalise among integer types.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-signed-integer,   mmec-signed-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-unsigned-integer, mmec-unsigned-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-signed-integer,   mmec-unsigned-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-unsigned-integer, mmec-signed-integer}

@c These are the methods that normalise among floating point types.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-floating-point, mmec-floating-point}

@c These are the methods that normalise mixed numeric types: `mmec-floating-point', `mmec-signed-integer', `mmec-unsigned-intger'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-floating-point,   mmec-signed-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-signed-integer,   mmec-floating-point}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-floating-point,   mmec-unsigned-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-unsigned-integer, mmec-floating-point}

@c These are the methods that normalise mixed numeric types: `integer' and `mmec-floating-point'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, integer, mmec-floating-point}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-floating-point, integer}

@c These are the methods that normalise mixed numeric types: `integer' and `mmec-signed-integer'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, integer, mmec-signed-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-signed-integer, integer}

@c These are the methods that normalise mixed numeric types: `integer' and `mmec-unsigned-integer'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, integer, mmec-unsigned-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-unsigned-integer, integer}

@c These are the methods that normalise mixed numeric types: `float' and `mmec-floating-point'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, float, mmec-floating-point}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-floating-point, float}

@c These are the methods that normalise mixed numeric types: `float' and `mmec-signed-integer'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, float, mmec-signed-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-signed-integer, float}

@c These are the methods that normalise mixed numeric types: `float' and `mmec-unsigned-integer'.
@mmuxDefunNumericComparisonMethod{\OPERATOR\, float, mmec-unsigned-integer}
@mmuxDefunNumericComparisonMethod{\OPERATOR\, mmec-unsigned-integer, float}
@end macro

@c ------------------------------------------------------------------------

@menu
* ctypes comparison eq::        Equality functions.
* ctypes comparison neq::       Non-equality functions.
* ctypes comparison less::      Less than functions.
* ctypes comparison greater::   Greater than functions.
* ctypes comparison leq::       Less than or equal to functions.
* ctypes comparison geq::       Greater than or equal to functions.
@end menu

@c page
@node ctypes comparison eq
@subsection Equality functions


@mmuxDefunNumericComparisonFunction{=, one equal to the other}

@c page
@node ctypes comparison neq
@subsection Non--equality functions


@mmuxDefunNumericComparisonFunction{/=, one not equal to the other}

@c page
@node ctypes comparison less
@subsection Less than functions


@mmuxDefunNumericComparisonFunction{<, one less than the other}

@c page
@node ctypes comparison greater
@subsection Greater than functions


@mmuxDefunNumericComparisonFunction{>, one greater than the other}

@c page
@node ctypes comparison leq
@subsection Less than or equal to functions


@mmuxDefunNumericComparisonFunction{<=, one less than or equal to the other}

@c page
@node ctypes comparison geq
@subsection Greater than or equal to functions


@mmuxDefunNumericComparisonFunction{>=, one greater than or equal to the other}

@c page
@node bytevec
@chapter Bytevector objects


@menu
* bytevec typedefs::            Bytevector type definitions.
* bytevec accessors::           Accessing bytevector slots.
* bytevec inspection::          Bytevector inspection function.
* bytevec comparison::          Comparing bytevectors.
* bytevec conversion::          Converting bytevectors to/from other
                                sequence objects.
@end menu

@c ------------------------------------------------------------------------

@macro ElispBytevectorTypeDefinition{TYPESTEM, PARENTSTEM, CTYPE}
@deftp {Object Type} mmec-\TYPESTEM\-bytevector
@deftpx {Parent Type} mmec-\PARENTSTEM\-bytevector
Object type of bytevectors holding number values of type @objtype{mmec-\TYPESTEM\}: the internal
binary array holds values of the C language type @code{\CTYPE\}.  Objects of this type are correctly
garbage collected.
@end deftp


@defun mmec-\TYPESTEM\-bytevector-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{mmec-\TYPESTEM\-bytevector}; otherwise return
false.
@end defun


@deffn {Generic Function} mmec-\TYPESTEM\-bytevector @var{NUMBER-OF-SLOTS}
@deffnx {Generic Function} mmec-\TYPESTEM\-bytevector ((@var{NUMBER-OF-SLOTS} integer))
Build and return a new @objtype{mmec-\TYPESTEM\-bytevector}.

The argument @var{NUMBER-OF-SLOTS} must be a non--negative exact integer representing the number of
slots; if its value is invalid the condition
@code{mmec-error-bytevector-constructor-invalid-number-of-slots} is signalled.
@end deffn


@ElispBytevectorCommonMethods{\TYPESTEM\, \PARENTSTEM\, \CTYPE\}
@end macro

@c ------------------------------------------------------------------------

@macro ElispBytevectorCommonMethods{TYPESTEM, PARENTSTEM, CTYPE}
@deffn {Method} mmec-bytevector-ref (@var{BV} mmec-\TYPESTEM\-bytevector) (@var{IDX} integer)
Extract a value of C language type @code{\CTYPE\} from the binary data area of @var{BV}, at slot
index @var{IDX}, and return it as value of type @objtype{mmec-\TYPESTEM\}.  If the slot index
@var{IDX} is invalid: raise the condition @code{mmec-error-bytevector-index-out-of-range}.
@end deffn


@deffn {Method} mmec-bytevector-set (@var{BV} mmec-\TYPESTEM\-bytevector) (@var{IDX} integer) (@var{VAL} mmec-\TYPESTEM\)
Extract a value of C language type @code{\CTYPE\} from the value @var{VAL} and store it in the
binary data area of @var{BV}, at slot index @var{IDX}; return @nil{}.  If the slot index @var{IDX}
is invalid: raise the condition @code{mmec-error-bytevector-index-out-of-range}.
@end deffn

@end macro

@c page
@node bytevec typedefs
@section Bytevector type definitions


@menu
* bytevec typedefs base::             Abstract base bytevector type.
* bytevec typedefs integer::          Abstract bytevector type for integers.
* bytevec typedefs signed-integer::   Abstract bytevector type for signed integers.
* bytevec typedefs unsigned-integer:: Abstract bytevector type for unsigned integers.
* bytevec typedefs floating-point::   Abstract bytevector type for floating-point numbers.
* bytevec typedefs char::             Bytevector of @code{char} values.
* bytevec typedefs schar::            Bytevector of @code{schar} values.
* bytevec typedefs uchar::            Bytevector of @code{uchar} values.
* bytevec typedefs wchar::            Bytevector of @code{wchar} values.
* bytevec typedefs sshrt::            Bytevector of @code{sshrt} values.
* bytevec typedefs ushrt::            Bytevector of @code{ushrt} values.
* bytevec typedefs sint::             Bytevector of @code{sint} values.
* bytevec typedefs uint::             Bytevector of @code{uint} values.
* bytevec typedefs slong::            Bytevector of @code{slong} values.
* bytevec typedefs ulong::            Bytevector of @code{ulong} values.
* bytevec typedefs sllong::           Bytevector of @code{sllong} values.
* bytevec typedefs ullong::           Bytevector of @code{ullong} values.
* bytevec typedefs sintmax::          Bytevector of @code{sintmax} values.
* bytevec typedefs uintmax::          Bytevector of @code{uintmax} values.
* bytevec typedefs ssize::            Bytevector of @code{ssize} values.
* bytevec typedefs usize::            Bytevector of @code{usize} values.
* bytevec typedefs ptrdiff::          Bytevector of @code{ptrdiff} values.
* bytevec typedefs sint8::            Bytevector of @code{sint8} values.
* bytevec typedefs uint8::            Bytevector of @code{uint8} values.
* bytevec typedefs sint16::           Bytevector of @code{sint16} values.
* bytevec typedefs uint16::           Bytevector of @code{uint16} values.
* bytevec typedefs sint32::           Bytevector of @code{sint32} values.
* bytevec typedefs uint32::           Bytevector of @code{uint32} values.
* bytevec typedefs sint64::           Bytevector of @code{sint64} values.
* bytevec typedefs uint64::           Bytevector of @code{uint64} values.
* bytevec typedefs float::            Bytevector of @code{float} values.
* bytevec typedefs double::           Bytevector of @code{double} values.
* bytevec typedefs ldouble::          Bytevector of @code{ldouble} values.
@end menu

@c page
@node bytevec typedefs base
@subsection Abstract base bytevector type


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.  All the
following types are to be considered ``abstract'', so we must not instantiate them.


@deftp {Object Type} mmec-bytevector
Base type of bytevector objects: it can represent binary data with a C language array.  Objects of
this type are correctly garbage collected.  It has the following fields:

@table @code
@item number-of-slots
Non--negative exact integer representing the number of slots in a bytevector.

@item slot-size
Non--negative exact integer representing the size of a slot measured in bytes.

@item number-of-allocated-bytes
Non--negative exact integer representing the number of bytes allocated in the data area.

@item signed-p
Boolean, true if the data in each slot is to be interpreted as a signed integer; false if it has to
be interpreted as an unsigned integer.

@item obj
User--pointer object.
@end table
@end deftp


@defun mmec-bytevector-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{mmec-bytevector}; otherwise return false.
@end defun


@defun mmec-bytevector-number-of-slots @var{BV}
@defunx mmec-bytevector-slot-size @var{BV}
@defunx mmec-bytevector-number-of-allocated-bytes @var{BV}
@defunx mmec-bytevector-signed-p @var{BV}
@defunx mmec-bytevector-obj @var{BV}
Field getters for bytevector objects.
@end defun

@c page
@node bytevec typedefs integer
@subsection Abstract bytevector type for integers


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.  All the
following types are to be considered ``abstract'', so we must not instantiate them.


@deftp {Object Type} mmec-integer-bytevector
@deftpx {Parent Type} mmec-bytevector
Base type of bytevector objects holding C language integers in their slots.  Objects of this type
are correctly garbage collected.
@end deftp


@defun mmec-integer-bytevector-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{mmec-integer-bytevector}; otherwise return false.
@end defun

@c page
@node bytevec typedefs signed-integer
@subsection Abstract bytevector type for signed integers


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.  All the
following types are to be considered ``abstract'', so we must not instantiate them.


@deftp {Object Type} mmec-signed-integer-bytevector
@deftpx {Parent Type} mmec-integer-bytevector
Base type of bytevector objects holding C language signed integers in their slots.  Objects of this
type are correctly garbage collected.
@end deftp


@defun mmec-signed-integer-bytevector-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{mmec-signed-integer-bytevector}; otherwise
return false.
@end defun

@c page
@node bytevec typedefs unsigned-integer
@subsection Abstract bytevector type for unsigned integers


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.  All the
following types are to be considered ``abstract'', so we must not instantiate them.


@deftp {Object Type} mmec-unsigned-integer-bytevector
@deftpx {Parent Type} mmec-integer-bytevector
Base type of bytevector objects holding C language unsigned integers in their slots.  Objects of
this type are correctly garbage collected.
@end deftp


@defun mmec-unsigned-integer-bytevector-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{mmec-unsigned-integer-bytevector}; otherwise
return false.
@end defun

@c page
@node bytevec typedefs floating-point
@subsection Abstract bytevector type for floating--point numbers


The following syntactic bindings are defined in the module @value{PackageEmacsModule}.  All the
following types are to be considered ``abstract'', so we must not instantiate them.


@deftp {Object Type} mmec-floating-point-bytevector
@deftpx {Parent Type} mmec-bytevector
Base type of bytevector objects holding C language floating--point values in their slots.  Objects
of this type are correctly garbage collected.
@end deftp


@defun mmec-floating-point-bytevector-p @var{OBJ}
Return true if @var{OBJ} is an instance of @objtype{mmec-floating-point-bytevector}; otherwise
return false.
@end defun

@c page
@node bytevec typedefs char
@subsection Bytevector of @code{char} values


@ElispBytevectorTypeDefinition{char, signed-integer, char}

@c page
@node bytevec typedefs schar
@subsection Bytevector of @code{schar} values


@ElispBytevectorTypeDefinition{schar, signed-integer, signed char}

@c page
@node bytevec typedefs uchar
@subsection Bytevector of @code{uchar} values


@ElispBytevectorTypeDefinition{uchar, unsigned-integer, unsigned char}

@c page
@node bytevec typedefs wchar
@subsection Bytevector of @code{wchar} values


@ElispBytevectorTypeDefinition{wchar, unsigned-integer, wchar_t}

@c page
@node bytevec typedefs sshrt
@subsection Bytevector of @code{sshrt} values


@ElispBytevectorTypeDefinition{sshrt, signed-integer, signed short int}

@c page
@node bytevec typedefs ushrt
@subsection Bytevector of @code{ushrt} values


@ElispBytevectorTypeDefinition{ushrt, unsigned-integer, unsigned short int}

@c page
@node bytevec typedefs sint
@subsection Bytevector of @code{sint} values


@ElispBytevectorTypeDefinition{sint, signed-integer, signed int}

@c page
@node bytevec typedefs uint
@subsection Bytevector of @code{uint} values


@ElispBytevectorTypeDefinition{uint, unsigned-integer, unsigned int}

@c page
@node bytevec typedefs slong
@subsection Bytevector of @code{slong} values


@ElispBytevectorTypeDefinition{slong, signed-integer, signed long int}

@c page
@node bytevec typedefs ulong
@subsection Bytevector of @code{ulong} values


@ElispBytevectorTypeDefinition{ulong, unsigned-integer, unsigned long int}

@c page
@node bytevec typedefs sllong
@subsection Bytevector of @code{sllong} values


@ElispBytevectorTypeDefinition{sllong, signed-integer, signed long long int}

@c page
@node bytevec typedefs ullong
@subsection Bytevector of @code{ullong} values


@ElispBytevectorTypeDefinition{ullong, unsigned-integer, unsigned long long int}

@c page
@node bytevec typedefs sintmax
@subsection Bytevector of @code{sintmax} values


@ElispBytevectorTypeDefinition{sintmax, signed-integer, intmax_t}

@c page
@node bytevec typedefs uintmax
@subsection Bytevector of @code{uintmax} values


@ElispBytevectorTypeDefinition{uintmax, unsigned-integer, uintmax_t}

@c page
@node bytevec typedefs ssize
@subsection Bytevector of @code{ssize} values


@ElispBytevectorTypeDefinition{ssize, signed-integer, ssize_t}

@c page
@node bytevec typedefs usize
@subsection Bytevector of @code{usize} values


@ElispBytevectorTypeDefinition{usize, unsigned-integer, size_t}

@c page
@node bytevec typedefs ptrdiff
@subsection Bytevector of @code{ptrdiff} values


@ElispBytevectorTypeDefinition{ptrdiff, signed-integer, ptrdiff_t}

@c page
@node bytevec typedefs sint8
@subsection Bytevector of @code{sint8} values


@ElispBytevectorTypeDefinition{sint8, signed-integer, int8_t}

@c page
@node bytevec typedefs uint8
@subsection Bytevector of @code{uint8} values


@ElispBytevectorTypeDefinition{uint8, unsigned-integer, uint8_t}

@c page
@node bytevec typedefs sint16
@subsection Bytevector of @code{sint16} values


@ElispBytevectorTypeDefinition{sint16, signed-integer, int16_t}

@c page
@node bytevec typedefs uint16
@subsection Bytevector of @code{uint16} values


@ElispBytevectorTypeDefinition{uint16, unsigned-integer, uint16_t}

@c page
@node bytevec typedefs sint32
@subsection Bytevector of @code{sint32} values


@ElispBytevectorTypeDefinition{sint32, signed-integer, int32_t}

@c page
@node bytevec typedefs uint32
@subsection Bytevector of @code{uint32} values


@ElispBytevectorTypeDefinition{uint32, unsigned-integer, uint32_t}

@c page
@node bytevec typedefs sint64
@subsection Bytevector of @code{sint64} values


@ElispBytevectorTypeDefinition{sint64, signed-integer, int64_t}

@c page
@node bytevec typedefs uint64
@subsection Bytevector of @code{uint64} values


@ElispBytevectorTypeDefinition{uint64, unsigned-integer, uint64_t}

@c page
@node bytevec typedefs float
@subsection Bytevector of @code{float} values


@ElispBytevectorTypeDefinition{float, floating-point, float}

@c page
@node bytevec typedefs double
@subsection Bytevector of @code{double} values


@ElispBytevectorTypeDefinition{double, floating-point, double}

@c page
@node bytevec typedefs ldouble
@subsection Bytevector of @code{ldouble} values


@ElispBytevectorTypeDefinition{ldouble, floating-point, long double}

@c page
@node bytevec accessors
@section Accessing bytevector slots


@deffn {Generic Function} mmec-bytevector-ref @var{BV} @var{IDX}
Extract the value at slot index @var{IDX} from the bytevector @var{BV}.  The argument @var{BV} must
be a concrete subtype of @objtype{mmec-bytevector}.  The argument @var{IDX} must be a non--negative
number value of type @objtype{integer}; if the slot index @var{IDX} is invalid: raise the condition
@code{mmec-error-bytevector-index-out-of-range}.
@end deffn


@deffn {Generic Function} mmec-bytevector-set @var{BV} @var{IDX} @var{VAL}
Store the value @var{VAL} into the bytevector @var{BV} at index @var{IDX}.  The argument @var{BV}
must be a concrete subtype of @objtype{mmec-bytevector}.  The argument @var{IDX} must be a
non--negative number value of type @objtype{integer}; if the slot index @var{IDX} is invalid: raise
the condition @code{mmec-error-bytevector-index-out-of-range}.  The argument @var{VAL} must be a
number object of type compatible with @var{BV}.
@end deffn

@c page
@node bytevec inspection
@section Bytevector inspection function


@deffn {Generic Function} mmec-bytevector-empty-p @var{BV}
@deffnx {Method} mmec-bytevector-empty-p (@var{BV} mmec-bytevector)
Return true if the bytevector @var{BV} is empty; otherwise return false.
@end deffn


@deffn {Generic Function} mmec-bytevector-not-empty-p @var{BV}
@deffnx {Method} mmec-bytevector-not-empty-p @var{BV}
Return true if the bytevector @var{BV} is not empty; otherwise return false.
@end deffn


@deffn {Generic Function} mmec-bytevector-last-slot-index @var{BV}
@deffnx {Method} mmec-bytevector-last-slot-index (@var{BV} mmec-bytevector)
Return a value of type @objtype{integer} representing the slot index of the last slot.  If the
bytevector is empty: signal the condition @code{mmec-error-bytevector-is-empty}.
@end deffn


@deffn {Generic Function} mmec-bytevector-valid-slot-index-p @var{BV} @var{IDX}
@deffnx {Method} mmec-bytevector-valid-slot-index-p (@var{BV} mmec-bytevector) (@var{IDX} integer)
Returnx true if @var{IDX} is a valid slot index for the bytevector @var{BV}; otherwise return false.
@end deffn


@deffn {Generic Function} mmec-bytevector-valid-past-slot-index-p (@var{BV} mmec-bytevector) (@var{IDX} integer)
Return true if @var{IDX} is a valid end--of--span slot index for the bytevector @var{BV}; otherwise
Returnx tMethod @var{IDX} is a valid end--of--span slot index for the bytevector @var{BV}; otherwise
return false.
@end deffn


@deffn {Generic Function} mmec-bytevector-valid-start-and-past-p @var{BV} @var{START} @var{PAST}
@deffnx {Method} mmec-bytevector-valid-start-and-past-p (@var{BV} mmec-bytevector) (@var{START} integer) (@var{PAST} integer)
Return true if @var{START} and @var{PAST} are valid slot span selectors for the bytevector @var{BV};
otherwise return false.
@end deffn

@c page
@node bytevec comparison
@section Comparing bytevectors


@menu
* bytevec comparison api::      Main comparison functions.
* bytevec comparison generics:: Comparison generic functions.
* bytevec comparison methods::  Comparison method functions.
@end menu

@c ------------------------------------------------------------------------

@macro DocBytevectorComparisonFunctionsCommonArguments{}
For all the comparison functions, the arguments @var{START} and @var{PAST} must be valid slot
indexes satisfying the conditions:

@example
0 <= @var{START} <= @var{PAST} <= number of slots
@end example

@noindent
otherwise the behaviour of the functions is undefined.  The functions compare a span in the data
area of the bytevectors starting at slot index @var{START}, included, and ending at slot index
@var{PAST}, excluded.
@end macro

@c ------------------------------------------------------------------------

@macro DocBytevectorComparisonFunctionsCommonRetvals{}
@table @code
@item 0
If the following condition is true:

@example
(@vari{PAST} - @vari{START}) == (@varii{PAST} - @varii{START})
@end example

@noindent
@strong{and} all the values in the slots are equal slot by slot.

@item +1
If the following condition is true:

@example
(@vari{PAST} - @vari{START}) > (@varii{PAST} - @varii{START})
@end example

@noindent
@strong{or} the span lengths are equal and, while visiting the slots from @var{START} to @var{PAST},
@vari{BV} holds a slot value that is greater than the corresponding slot value in @varii{BV}.

@item -1
If the following condition is true:

@example
(@vari{PAST} - @vari{START}) < (@varii{PAST} - @varii{START})
@end example

@noindent
@strong{or} the span lengths are equal and, while visiting the slots from @var{START} to @var{PAST},
@vari{BV} holds a slot value that is less than the corresponding slot value in @varii{BV}.
@end table
@end macro

@c page
@node bytevec comparison api
@subsection Main comparison functions


Bytevector comparison is performed by visiting a bytevector's slots, left to right, and comparing
the slots one by one, stopping at the first different values.

All the functions described below accept the following keys that specify a span in the bytevectors
to use in the comparison:

@table @code
@item :start1
Select the inclusive slot index in @vari{BV} from which to start the comparison.  Defaults to
@samp{0}.

@item :start2
Select the inclusive slot index in @varii{BV} from which to start the comparison.  Defaults to
@samp{0}.

@item :past1
Select the exclusive slot index in @vari{BV} at which to end the comparison.  Defaults to the number
of slots in @vari{BV}.

@item :past2
Select the exclusive slot index in @varii{BV} at which to end the comparison.  Defaults to the
number of slots in @varii{BV}.
@end table

@DocBytevectorComparisonFunctionsCommonArguments{}


@defun mmec-bytevector-compare @vari{BV} @varii{BV} &key @var{key} @dots{}
Compare two bytevectors.  Return the following code:

@DocBytevectorComparisonFunctionsCommonRetvals{}

This function is an adapter for the generic function @func{mmec-bytevector-compare-6} and it returns
its return value.
@end defun


@macro ElispBytevectorComparisonApiFunctions{STEM}
@defun mmec-bytevector-\STEM\ @vari{BV} @varii{BV} &key @var{key} @dots{}
Compare two bytevectors; return true if the comparison condition is true, otherwise return false.
This function is an adapter for the generic function @func{mmec-bytevector-\STEM\-6} and it returns
its return value.
@end defun

@end macro

@ElispBytevectorComparisonApiFunctions{equal}
@ElispBytevectorComparisonApiFunctions{less}
@ElispBytevectorComparisonApiFunctions{greater}
@ElispBytevectorComparisonApiFunctions{leq}
@ElispBytevectorComparisonApiFunctions{geq}

@c page
@node bytevec comparison generics
@subsection Comparison generic functions


Bytevector comparison is performed by visiting a bytevector's slots, left to right, and comparing
the slots one by one, stopping at the first different values.

@DocBytevectorComparisonFunctionsCommonArguments{}


@deffn {Generic Function} mmec-bytevector-compare-6 @vari{BV} @vari{START} @vari{PAST} @varii{BV} @varii{START} @varii{PAST}
Compare the selected spans in the bytevectors @vari{BV} and @varii{BV}, return the following code:

@DocBytevectorComparisonFunctionsCommonRetvals{}
@end deffn


@deffn {Generic Function} mmec-bytevector-equal-6 @vari{BV} @vari{START} @vari{PAST} @varii{BV} @varii{START} @varii{PAST}
@deffnx {Generic Function} mmec-bytevector-less-6 @vari{BV} @vari{START} @vari{PAST} @varii{BV} @varii{START} @varii{PAST}
@deffnx {Generic Function} mmec-bytevector-greater-6 @vari{BV} @vari{START} @vari{PAST} @varii{BV} @varii{START} @varii{PAST}
@deffnx {Generic Function} mmec-bytevector-leq-6 @vari{BV} @vari{START} @vari{PAST} @varii{BV} @varii{START} @varii{PAST}
@deffnx {Generic Function} mmec-bytevector-geq-6 @vari{BV} @vari{START} @vari{PAST} @varii{BV} @varii{START} @varii{PAST}
Compare the selected spans in the bytevectors @vari{BV} and @varii{BV}: return true if the
comparison condition is true; otherwise return false.
@end deffn

@c page
@node bytevec comparison methods
@subsection Comparison method functions


@DocBytevectorComparisonFunctionsCommonArguments{}


@macro ElispDefineBytevectorComparison{TYPESTEM}
@deffn {Method} mmec-bytevector-equal-6 (@vari{BV} mmec-\TYPESTEM\-bytevector) (@vari{START} integer) (@vari{PAST} integer) (@varii{BV} mmec-\TYPESTEM\-bytevector) (@varii{START} integer) (@varii{PAST} integer)
@deffnx {Method} mmec-bytevector-less-6 (@vari{BV} mmec-\TYPESTEM\-bytevector) (@vari{START} integer) (@vari{PAST} integer) (@varii{BV} mmec-\TYPESTEM\-bytevector) (@varii{START} integer) (@varii{PAST} integer)
@deffnx {Method} mmec-bytevector-greater-6 (@vari{BV} mmec-\TYPESTEM\-bytevector) (@vari{START} integer) (@vari{PAST} integer) (@varii{BV} mmec-\TYPESTEM\-bytevector) (@varii{START} integer) (@varii{PAST} integer)
@deffnx {Method} mmec-bytevector-leq-6 (@vari{BV} mmec-\TYPESTEM\-bytevector) (@vari{START} integer) (@vari{PAST} integer) (@varii{BV} mmec-\TYPESTEM\-bytevector) (@varii{START} integer) (@varii{PAST} integer)
@deffnx {Method} mmec-bytevector-geq-6 (@vari{BV} mmec-\TYPESTEM\-bytevector) (@vari{START} integer) (@vari{PAST} integer) (@varii{BV} mmec-\TYPESTEM\-bytevector) (@varii{START} integer) (@varii{PAST} integer)
Compare the selected spans in the bytevectors @vari{BV} and @varii{BV}: return @ctrue{} if the
comparison condition is true; otherwise return @cfalse{}.
@end deffn

@end macro


@ElispDefineBytevectorComparison{char}
@ElispDefineBytevectorComparison{schar}
@ElispDefineBytevectorComparison{uchar}
@ElispDefineBytevectorComparison{wchar}
@ElispDefineBytevectorComparison{sshrt}
@ElispDefineBytevectorComparison{ushrt}
@ElispDefineBytevectorComparison{sint}
@ElispDefineBytevectorComparison{uint}
@ElispDefineBytevectorComparison{slong}
@ElispDefineBytevectorComparison{ulong}
@ElispDefineBytevectorComparison{sllong}
@ElispDefineBytevectorComparison{ullong}
@ElispDefineBytevectorComparison{sintmax}
@ElispDefineBytevectorComparison{uintmax}
@ElispDefineBytevectorComparison{ssize}
@ElispDefineBytevectorComparison{usize}
@ElispDefineBytevectorComparison{ptrdiff}
@ElispDefineBytevectorComparison{sint8}
@ElispDefineBytevectorComparison{uint8}
@ElispDefineBytevectorComparison{sint16}
@ElispDefineBytevectorComparison{uint16}
@ElispDefineBytevectorComparison{sint32}
@ElispDefineBytevectorComparison{uint32}
@ElispDefineBytevectorComparison{sint64}
@ElispDefineBytevectorComparison{uint64}
@ElispDefineBytevectorComparison{float}
@ElispDefineBytevectorComparison{double}
@ElispDefineBytevectorComparison{ldouble}

@c page
@node bytevec conversion
@section Converting bytevectors to/from other sequence objects


@menu
* bytevec conversion list::     Converting bytevectors to/from lists.
* bytevec conversion vector::   Converting bytevectors to/from vectors.
@end menu

@c page
@node bytevec conversion list
@subsection Converting bytevectors to/from lists


@deffn {Generic Function} mmec-bytevector-to-list @var{BV}
Convert an object of type @objtype{mmec-bytevector} to or from a list of its elements.
@end deffn


@macro ElispConvertBytevectorToFromList{TYPESTEM}
@deffn {Generic Function} mmec-\TYPESTEM\-bytevector-from-list @var{LIST}
@deffnx {Method} mmec-\TYPESTEM\-bytevector-from-list (@var{LIST} list)
@deffnx {Method} mmec-bytevector-to-list (@var{BV} mmec-\TYPESTEM\-bytevector)
Convert a bytevector object of type @objtype{mmec-\TYPESTEM\-bytevector} to/from a list of its
elements.
@end deffn

@end macro


@ElispConvertBytevectorToFromList{char}
@ElispConvertBytevectorToFromList{schar}
@ElispConvertBytevectorToFromList{uchar}
@ElispConvertBytevectorToFromList{wchar}
@ElispConvertBytevectorToFromList{sshrt}
@ElispConvertBytevectorToFromList{ushrt}
@ElispConvertBytevectorToFromList{sint}
@ElispConvertBytevectorToFromList{uint}
@ElispConvertBytevectorToFromList{slong}
@ElispConvertBytevectorToFromList{ulong}
@ElispConvertBytevectorToFromList{sllong}
@ElispConvertBytevectorToFromList{ullong}
@ElispConvertBytevectorToFromList{sintmax}
@ElispConvertBytevectorToFromList{uintmax}
@ElispConvertBytevectorToFromList{ssize}
@ElispConvertBytevectorToFromList{usize}
@ElispConvertBytevectorToFromList{ptrdiff}
@ElispConvertBytevectorToFromList{sint8}
@ElispConvertBytevectorToFromList{uint8}
@ElispConvertBytevectorToFromList{sint16}
@ElispConvertBytevectorToFromList{uint16}
@ElispConvertBytevectorToFromList{sint32}
@ElispConvertBytevectorToFromList{uint32}
@ElispConvertBytevectorToFromList{sint64}
@ElispConvertBytevectorToFromList{uint64}
@ElispConvertBytevectorToFromList{float}
@ElispConvertBytevectorToFromList{double}
@ElispConvertBytevectorToFromList{ldouble}

@c page
@node bytevec conversion vector
@subsection Converting bytevectors to/from vectors


@deffn {Generic Function} mmec-bytevector-to-vector @var{BV}
Convert an object of type @objtype{mmec-bytevector} to or from a vector of its elements.
@end deffn


@macro ElispConvertBytevectorToFromVector{TYPESTEM}
@deffn {Generic Function} mmec-\TYPESTEM\-bytevector-from-vector @var{VECTOR}
@deffnx {Method} mmec-\TYPESTEM\-bytevector-from-vector (@var{VECTOR} vector)
@deffnx {Method} mmec-bytevector-to-vector (@var{BV} mmec-\TYPESTEM\-bytevector)
Convert a bytevector object of type @objtype{mmec-\TYPESTEM\-bytevector} to/from a vector of its
elements.
@end deffn

@end macro


@ElispConvertBytevectorToFromVector{char}
@ElispConvertBytevectorToFromVector{schar}
@ElispConvertBytevectorToFromVector{uchar}
@ElispConvertBytevectorToFromVector{wchar}
@ElispConvertBytevectorToFromVector{sshrt}
@ElispConvertBytevectorToFromVector{ushrt}
@ElispConvertBytevectorToFromVector{sint}
@ElispConvertBytevectorToFromVector{uint}
@ElispConvertBytevectorToFromVector{slong}
@ElispConvertBytevectorToFromVector{ulong}
@ElispConvertBytevectorToFromVector{sllong}
@ElispConvertBytevectorToFromVector{ullong}
@ElispConvertBytevectorToFromVector{sintmax}
@ElispConvertBytevectorToFromVector{uintmax}
@ElispConvertBytevectorToFromVector{ssize}
@ElispConvertBytevectorToFromVector{usize}
@ElispConvertBytevectorToFromVector{ptrdiff}
@ElispConvertBytevectorToFromVector{sint8}
@ElispConvertBytevectorToFromVector{uint8}
@ElispConvertBytevectorToFromVector{sint16}
@ElispConvertBytevectorToFromVector{uint16}
@ElispConvertBytevectorToFromVector{sint32}
@ElispConvertBytevectorToFromVector{uint32}
@ElispConvertBytevectorToFromVector{sint64}
@ElispConvertBytevectorToFromVector{uint64}
@ElispConvertBytevectorToFromVector{float}
@ElispConvertBytevectorToFromVector{double}
@ElispConvertBytevectorToFromVector{ldouble}

@c page
@node errors
@chapter How errors are signalled


Occasionally the functions in @value{PACKAGE} signal an error; the following error symbols are
defined.


@defvr {Error Symbol} mmec-error
The base type of all the error symbols.
@end defvr


@menu
* errors constructor::          Constructor errors.
* errors range::                Range errors.
* errors operations::           Operation errors.
@end menu

@c page
@node errors constructor
@section Constructor errors


@defvr {Error Symbol} mmec-error-constructor
@defvrx {Parent Error Symbol} mmec-error
An error occurred while constructing an object.
@end defvr


@defvr {Error Symbol} mmec-error-no-memory
@defvrx {Parent Error Symbol} mmec-error-constructor
Used to signal that there was not enough memory to allocate an object.
@end defvr


@defvr {Error Symbol} mmec-error-instantiating-abstract-type
@defvrx {Parent Error Symbol} mmec-error-constructor
An attempt was performed to instantiate an abstract data type.
@end defvr


@defvr {Error Symbol} mmec-error-unsupported-init-type
@defvrx {Parent Error Symbol} mmec-error-constructor
An argument given to an object constructor has an unsupported type.
@end defvr


@defvr {Error Symbol} mmec-error-bytevector-constructor
@defvrx {Parent Error Symbol} mmec-error-constructor
An error occurred while building a bytevector object.
@end defvr


@defvr {Error Symbol} mmec-error-bytevector-constructor-invalid-number-of-slots
@defvrx {Parent Error Symbol} mmec-error-bytevector-constructor
An invalid number of slots was given as argument to a bytevector constructor.
@end defvr

@c page
@node errors range
@section Range errors


@defvr {Error Symbol} mmec-error-value-out-of-range
@defvrx {Parent Error Symbol} mmec-error
A numeric object is out of range.
@end defvr


@defvr {Error Symbol} mmec-error-index-out-of-range
@defvrx {Parent Error Symbol} mmec-error-value-out-of-range
Used to signal an attempt to access the internal represenation of an object with an index out of
range.
@end defvr


@defvr {Error Symbol} mmec-error-bytevector-index-out-of-range
@defvrx {Parent Error Symbol} mmec-error-index-out-of-range
Attempt to access the internal represenation of a bytevector object with an index out of range.
@end defvr


@defvr {Error Symbol} mmec-error-bytevector-is-empty
@defvrx {Parent Error Symbol} mmec-error-value-out-of-range
Used to signal that a bytevector operand is empty.
@end defvr

@c page
@node errors operations
@section Operation errors


@defvr {Error Symbol} mmec-error-signed/unsigned-integer-comparison
@defvrx {Parent Error Symbol} mmec-error
Cannot compare a signed integer with an unsigned integer.
@end defvr

@c page
@node capi
@chapter C language programming interface


@menu
* capi version::                Version informations.
* capi typedefs::               General type definitions.
* capi errors::                 Signalling errors.
* capi modules::                Modules related definitions.
* capi objects::                Handling Emacs Lisp objects.
* capi bytevec::                Bytevector objects.
@end menu

@c page
@node capi version
@section Version informations


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} mmec_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int mmec_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int mmec_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int mmec_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node capi typedefs
@section General type definitions


@menu
* capi typedefs clang::         C language type definitions.
@end menu

@c page
@node capi typedefs clang
@subsection C language type definitions


The following type definitions are useful when defining macros: every type name has the C language
specification in a single word, so we can build macro expansions with:

@example
#undef  THE_TYPE
#define THE_TYPE(STEM)          mmec_clang_ ## STEM ## _t

THE_TYPE(char)
THE_TYPE(sshrt)
THE_TYPE(ullong)
@end example


@deftp {Type definition} mmec_clang_char_t
An alias for the C language type @code{char}.
@end deftp


@deftp {Type definition} mmec_clang_schar_t
An alias for the C language type @code{signed char}.
@end deftp


@deftp {Type definition} mmec_clang_uchar_t
An alias for the C language type @code{unsigned char}.
@end deftp


@deftp {Type definition} mmec_clang_wchar_t
An alias for the C language type @code{wchar_t}.
@end deftp


@deftp {Type definition} mmec_clang_sshrt_t
An alias for the C language type @code{signed   short int}.
@end deftp


@deftp {Type definition} mmec_clang_ushrt_t
An alias for the C language type @code{unsigned short int}.
@end deftp


@deftp {Type definition} mmec_clang_sint_t
An alias for the C language type @code{signed   int}.
@end deftp


@deftp {Type definition} mmec_clang_uint_t
An alias for the C language type @code{unsigned int}.
@end deftp


@deftp {Type definition} mmec_clang_slong_t
An alias for the C language type @code{signed   long int}.
@end deftp


@deftp {Type definition} mmec_clang_ulong_t
An alias for the C language type @code{unsigned long int}.
@end deftp


@deftp {Type definition} mmec_clang_sllong_t
An alias for the C language type @code{signed   long long int}.
@end deftp


@deftp {Type definition} mmec_clang_ullong_t
An alias for the C language type @code{unsigned long long int}.
@end deftp


@deftp {Type definition} mmec_clang_ssize_t
An alias for the C language type @code{ssize_t}.
@end deftp


@deftp {Type definition} mmec_clang_usize_t
An alias for the C language type @code{size_t}.
@end deftp


@deftp {Type definition} mmec_clang_sintmax_t
An alias for the C language type @code{intmax_t}.
@end deftp


@deftp {Type definition} mmec_clang_uintmax_t
An alias for the C language type @code{uintmax_t}.
@end deftp


@deftp {Type definition} mmec_clang_ptrdiff_t
An alias for the C language type @code{ptrdiff_t}.
@end deftp


@deftp {Type definition} mmec_clang_sint8_t
An alias for the C language type @code{int8_t}.
@end deftp


@deftp {Type definition} mmec_clang_uint8_t
An alias for the C language type @code{uint8_t}.
@end deftp


@deftp {Type definition} mmec_clang_sint16_t
An alias for the C language type @code{int16_t}.
@end deftp


@deftp {Type definition} mmec_clang_uint16_t
An alias for the C language type @code{uint16_t}.
@end deftp


@deftp {Type definition} mmec_clang_sint32_t
An alias for the C language type @code{int32_t}.
@end deftp


@deftp {Type definition} mmec_clang_uint32_t
An alias for the C language type @code{uint32_t}.
@end deftp


@deftp {Type definition} mmec_clang_sint64_t
An alias for the C language type @code{int64_t}.
@end deftp


@deftp {Type definition} mmec_clang_uint64_t
An alias for the C language type @code{uint64_t}.
@end deftp


@deftp {Type definition} mmec_clang_float_t
An alias for the C language type @code{float}.
@end deftp


@deftp {Type definition} mmec_clang_double_t
An alias for the C language type @code{double}.
@end deftp


@deftp {Type definition} mmec_clang_ldouble_t
An alias for the C language type @code{long double}.
@end deftp

@c page
@node capi errors
@section Signalling errors


@menu
* capi errors typedefs::        Error signalling type definitions.
* capi errors macros::          Error signalling preprocessor macros.
* capi errors base::            Signalling base errors.
* capi errors constructor::     Signalling constructor errors.
* capi errors range::           Signalling range errors.
* capi errors operations::      Signalling operation errors.
@end menu

@c page
@node capi errors typedefs
@subsection Error signalling type definitions


@deftypefn {Function Protoype} emacs_value mmec_error_signaller_fun_t (emacs_env * @var{env})
Prototype of functions signalling an error.
@end deftypefn

@c page
@node capi errors macros
@subsection Error signalling preprocessor macros


@defmac MMEC_DEFINE_ERROR_SIGNALLER (@var{PREFIX}, @var{NAME}, @var{SYMBOL}, @var{MESSAGE})
Expand into the definition of an error signalling function.  The expansion is:

@example
emacs_value
PREFIX ## _error_ ## NAME (emacs_env * env)
@{
  char const   *errmsg = MESSAGE;
  emacs_value  Serrmsg = \
    mmec_new_emacs_string(env, errmsg, strlen(errmsg));

  env->non_local_exit_signal(env,
    env->intern(env, SYMBOL), Serrmsg);
  return env->intern(env, "nil");
@}
@end example

We could define an error signaller function with prototype:

@example
mmec_error_signaller_fun_t mmec_error_memory_allocation;
@end example

@noindent
as:

@example
MMEC_DEFINE_ERROR_SIGNALLER(mmec, memory_alloction,
  "mmec-error-no-memory",
  "Not enough memory available to allocate an object.")
@end example
@end defmac

@c page
@node capi errors base
@subsection Signalling base errors


@deftypefun emacs_value mmec_error_base (emacs_env * @var{env})
Signal an error with error symbol @code{mmec-error} then return @nil{}.
@end deftypefun

@c page
@node capi errors constructor
@subsection Signalling constructor errors


@deftypefun emacs_value mmec_error_constructor (emacs_env * @var{env})
Signal an error with symbol @code{mmec-error-constructor} then return @nil{}.
@end deftypefun


@deftypefun emacs_value mmec_error_memory_allocation (emacs_env * @var{env})
Signal an error with symbol @code{mmec-error-no-memory} then return @nil{}.
@end deftypefun


@deftypefun emacs_value mmec_error_instantiating_abstract_type (emacs_env * @var{env})
Signal an error with symbol @code{mmec-error-instantiating-abstract-type} then return @nil{}.
@end deftypefun


@deftypefun emacs_value mmec_error_unsupported_init_type (emacs_env * @var{env})
Signal an error with symbol @code{mmec-error-unsupported-init-type} then return @nil{}.
@end deftypefun


@deftypefun emacs_value mmec_error_bytevector_constructor (emacs_env * @var{env})
An error occurred while building a bytevector object.
@end deftypefun


@deftypefun emacs_value mmec_error_bytevector_constructor_invalid_number_of_slots (emacs_env * @var{env})
An invalid number of slots was given as argument to a bytevector constructor.
@end deftypefun

@c page
@node capi errors range
@subsection Signalling range errors


@deftypefun emacs_value mmec_error_value_out_of_range (emacs_env * @var{env})
Signal an error with symbol @code{mmec-error-value-out-of-range} then return @nil{}.
@end deftypefun


@deftypefun emacs_value mmec_error_index_out_of_range (emacs_env * @var{env})
Signal an error with symbol @code{mmec-error-index-out-of-range} then return @nil{}.
@end deftypefun


@deftypefun emacs_value mmec_error_bytevector_index_out_of_range (emacs_env * @var{env})
Signal an error with symbol @code{mmec-error-bytevector-index-out-of-range} then return @nil{}.
@end deftypefun


@deftypefun emacs_value mmec_error_error_bytevector_is_empty (emacs_env * @var{env})
Signal an error with symbol @code{mmec-error-bytevector-is-empty} then return @nil{}.
@end deftypefun

@c page
@node capi errors operations
@subsection Signalling operation errors


@deftypefun emacs_value mmec_error_signed_unsigned_integer_comparison (emacs_env * @var{env})
Signal an error with symbol @code{mmec-error-signed/unsigned-integer-comparison} then return @nil{}.
@end deftypefun

@c page
@node capi modules
@section Modules related definitions


Here is an example of how we can define Emacs Lisp functions at the C language level using the
facilities of @value{PACKAGE}:

@example
static emacs_value
Fspiffy_function (emacs_env *env, ptrdiff_t nargs,
                  emacs_value args[], void * data)
@{
  assert(0 == nargs);
  return mmec_new_elisp_nil(env);
@}

#define NUMBER_OF_MODULE_FUNCTIONS      1
static mmec_module_function_t const \
   module_functions_table[NUMBER_OF_MODULE_FUNCTIONS] = @{
  @{
    .name               = "spiffy-function",
    .implementation     = Fspiffy_function,
    .min_arity          = 0,
    .max_arity          = 0,
    .documentation      = "Do something spiffy."
  @}
@}

void
init_spiffy_module (emacs_env * env)
@{
  mmec_define_elisp_functions_from_table(env,
    module_functions_table, NUMBER_OF_MODULE_FUNCTIONS, 0);
@}
@end example


@deftypefn {Function Prototype} emacs_value mmec_elisp_function_implementation_t (emacs_env * @var{env}, ptrdiff_t @var{nargs}, emacs_value @var{args}[], void * @var{data})
Prototype of Emacs Lisp functions defined at the C language level.
@end deftypefn


@deftp {Struct Typedef} mmec_module_function_t
Structure type representing an Emacs Lisp function definition at the C language level.  Instances of
this type area meant to be defined in a an array and used to initialise a module.

@table @code
@item char const * name
Pointer to an @asciiz{} representing the name of the Emacs Lisp function.

@item mmec_elisp_function_implementation_t * implementation
Pointer to the C language function implementing the Emacs Lisp function.

@item ptrdiff_t min_arity
Minimum number of arguments accepted by the Emacs Lisp function.  It is the minimum number of items
in the array @var{args} of the functions with type @objtype{mmec_elisp_function_implementation_t}.

@item ptrdiff_t max_arity
Maximum number of arguments accepted by the Emacs Lisp function.  It is the maximum number of items
in the array @var{args} of the functions with type @objtype{mmec_elisp_function_implementation_t}.

@item char const * documentation
Pointer to an @asciiz{} representing the documentation of the Emacs Lisp function.
@end table
@end deftp


@deftypefun void mmec_define_elisp_functions_from_table (emacs_env * @var{env}, mmec_module_function_t const * @var{module_functions}, int @var{number_of_module_functions}, int @var{verbose})
Define a number of Emacs Lisp functions at the C language level.

The argument @var{env} must be the environment in which the functions will be defined.

The argument @var{module_functions} must be a pointer to an array of Emacs Lisp function
definitions.

The argument @var{number_of_module_functions} must be the number of items in the array referenced by
@var{module_functions}.

If the argument @var{verbose} is true: for every defined function, a string representing the
function name is printed to @code{stderr}, terminated by a newline; otherwise nothing is printed.
@end deftypefun

@c page
@node capi objects
@section Handling Emacs Lisp objects


@menu
* capi objects elisp::          Handling Emacs built-in values.
* capi objects usrptr::         Defining user-pointer objects.
* capi objects clang::          Wrappers for C language values.
@end menu

@c page
@node capi objects elisp
@subsection Handling Emacs built--in values


@menu
* capi objects elisp getters::  Retrieving values from Emacs built-in values.
* capi objects elisp makers::   Making new Emacs built-in values.
@end menu

@c page
@node capi objects elisp getters
@subsubsection Retrieving values from Emacs built--in values


@deftypefun {void *} mmec_get_usrptr_object_from_emacs_value (emacs_env * @var{env}, emacs_value @var{arg})
Given an Emacs Lisp value @var{arg} in the context of the environment @var{env}: get from it a
pointer to a user--pointer object; return the pointer.  The returned value is the internal
representation of @var{arg}, so if we mutate it we will mutate the value @var{arg} itself.

If @var{arg} is not a user--pointer object: the @code{wrong-type-argument} error condition is
raised.
@end deftypefun


@deftypefun intmax_t mmec_extract_elisp_integer_from_emacs_value (emacs_env * @var{env}, emacs_value @var{arg})
Given an Emacs Lisp value @var{arg} in the context of the environment @var{env}: extract from it an
exact integer number; return the number.  The returned value is independent from the internal
representation of @var{arg}.

If @var{arg} is not an exact integer value: the @code{wrong-type-argument} error condition is
raised.
@end deftypefun


@deftypefun double mmec_extract_elisp_float_from_emacs_value (emacs_env * @var{env}, emacs_value @var{arg})
Given an Emacs Lisp value @var{arg} in the context of the environment @var{env}: extract from it a
double--precision floating point number; return the number.  The returned value is independent from
the internal representation of @var{arg}.

If @var{arg} is not an exact integer value: the @code{wrong-type-argument} error condition is
raised.
@end deftypefun


@deftypefun bool mmec_extract_boolean_from_emacs_value (emacs_env * @var{env}, emacs_value @var{arg})
Return false if @var{arg} is @nil{}; otherwise return true.
@end deftypefun

@c page
@node capi objects elisp makers
@subsubsection Making new Emacs built--in values


@deftypefun emacs_value mmec_new_emacs_value_from_usrptr_object (emacs_env * @var{env}, mmec_usrptr_object_finalizer_t @var{finalizer}, void * @var{ptr})
@anchor{mmec_new_emacs_value_from_usrptr_object}
Build and return a new Emacs built--in value from the raw pointer of a user--pointer object
@var{ptr} in the context of the environment @var{env}.  The argument @var{finalizer} must be a
pointer to the user--pointer object destructor.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_nil (emacs_env * @var{env})
Build and return an Emacs built--in value representing the interned symbol @code{nil}, in the
context of the environment @var{env}.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_true (emacs_env * @var{env})
Build and return an Emacs built--in value representing the interned symbol @code{t}, in the context
of the environment @var{env}.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_boolean (emacs_env * @var{env}, int @var{val})
Build and return an Emacs built--in value representing either the interned symbol @code{nil} (if
@var{val} is zero) or the interned symbol @code{t} (if @var{val} is non--zero), in the context of
the environment @var{env}.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_integer (emacs_env * @var{env}, intmax_t @var{val})
Build and return an Emacs built--in value representing the exact integer @var{val}, in the context
of the environment @var{env}.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_float (emacs_env * @var{env}, double @var{val})
Build and return an Emacs built--in value representing the double--precision floating point number
@var{val}, in the context of the environment @var{env}.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_string (emacs_env * @var{env}, char const * @var{ptr}, size_t @var{len})
Build and return an Emacs built--in value representing the @ascii{} string referenced by @var{ptr},
of length @var{len}, in the context of the environment @var{env}.  The C language string is
duplicated in the internal representation of the returned value.
@end deftypefun

@c page
@node capi objects usrptr
@subsection Defining user--pointer objects


@deftypefn {Function Prototype} void mmec_usrptr_object_finalizer_func_t (void * @var{ptr})
Prototype of C language functions usable as user--pointer object destructors.
@end deftypefn


@deftp {Pointer Typedef} mmec_usrptr_object_finalizer_t
Type of pointers to C language functions usable as user--pointer object destructors.  We can use
values of this type as arguments in calls to @cfunc{mmec_new_emacs_value_from_usrptr_object},
@ref{mmec_new_emacs_value_from_usrptr_object}.
@end deftp

@c page
@node capi objects clang
@subsection Wrappers for C language values


@value{PACKAGE} defines a custom value type for every standard C language type we might need when
interfacing with a foreign C language library.  At the Emacs lisp level: these values are
represented by instances of a structure type defined with @func{cl-defstruct}, every structure holds
an Emacs Lisp value as internal representation:

@itemize
@item
Exact integer values that fit into an Emacs built--in @objtype{integer} value have @objtype{integer}
values as internal representation.

@item
Exact integer values that do not fit into an Emacs built--in @objtype{integer} value have a
user--pointer object value as internal representation.

@item
Floating--point values of type @code{double} have Emacs built--in @objtype{float} values as internal
representation.

@item
Floating--point values of type @code{float} and @code{long double} have a user--pointer object value
as internal representation.

@end itemize

At the C language level:

@itemize
@item
Exact integer values that fit into an Emacs built--in @objtype{integer} value have @code{intmax_t}
values as internal representation and we can cast such values to the specific C language type.

@item
Exact integer values that do not fit into an Emacs built--in @objtype{integer} value have a C
language structure as internal representation, with memory dynamically allocated.

@item
Floating--point values of type @code{double} have @code{double} values as internal representation.

@item
Floating--point values of type @code{float} and @code{long double} have a C language structure as
internal representation, with memory dynamically allocated.
@end itemize

@c ------------------------------------------------------------------------

@macro DocumentNumberValueWithIntegerRep{STEM, CTYPE}
@node capi objects clang \STEM\
@subsubsection Wrapper of @code{\CTYPE\}


@deftp {Type Definition} mmec_intrep_\STEM\_t
Type of internal representation for objects wrapping a C language value of type @code{\CTYPE\}.  It
is an alias for @code{intmax_t}.
@end deftp

@subsubheading Extractors

@deftypefun mmec_intrep_\STEM\_t mmec_extract_intrep_\STEM\_from_emacs_value (emacs_env * @var{ENV}, emacs_value @var{ARG})
Given the Emacs value @var{ARG}, in the context of the environment @var{ENV}: extract its internal
representation wrapping the C language value; return the representation itself.  The returned value
is independent from @var{ARG}.

If @var{ARG} is not an Emacs built--in value of type @objtype{integer}: the
@code{wrong-type-argument} error condition is raised.
@end deftypefun


@deftypefun mmec_clang_\STEM\_t mmec_extract_clang_\STEM\_from_emacs_value (emacs_env * @var{ENV}, emacs_value @var{ARG})
Given the Emacs value @var{ARG}, in the context of the environment @var{ENV}: extract from its
representation the raw C language value; return the raw value itself.  The returned value is
independent from @var{ARG}.

If @var{ARG} is not an Emacs built--in value of type @objtype{integer}: the
@code{wrong-type-argument} error condition is raised.
@end deftypefun


@deftypefun mmec_clang_\STEM\_t mmec_extract_clang_\STEM\_from_intrep_\STEM\ (mmec_intrep_\STEM\_t @var{IREP})
Given the internal representation of a wrapper for the C language type @code{\CTYPE\}, extract and
return its value as raw C language value.  The returned value is independent from @var{IREP}.
@end deftypefun

@subsubheading Constructors

@deftypefun mmec_intrep_\STEM\_t mmec_new_intrep_\STEM\_from_clang_\STEM\ (mmec_clang_\STEM\_t @var{VAL})
Given the raw C language value @var{VAL} wrap it into its internal representation and return the
result.  The returned value is independent from @var{VAL}.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_from_intrep_\STEM\ (emacs_env * @var{ENV}, mmec_intrep_\STEM\_t @var{IREP})
Given the internal representation @var{IREP} of a C language value: build and return a new Emacs
value, in the context of the environment @var{ENV}, representing the C language value.  The returned
object is independent from @var{IREP}.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_from_clang_\STEM\ (emacs_env * @var{ENV}, mmec_clang_\STEM\_t @var{VAL})
Given a raw C language value @var{VAL}: build and return a new Emacs value, in the context of the
environment @var{ENV}, representing the value.  The returned object is independent from @var{VAL}.
@end deftypefun
@end macro

@c ------------------------------------------------------------------------

@macro DocumentNumberValueWithFloatRep{STEM, CTYPE}
@node capi objects clang \STEM\
@subsubsection Wrapper of @code{\CTYPE\}


@deftp {Type Definition} mmec_intrep_\STEM\_t
Type of internal representation for objects wrapping a C language value of type @code{\CTYPE\}.  It
is an alias for @code{double}.
@end deftp

@subsubheading Extractors

@deftypefun mmec_intrep_\STEM\_t mmec_extract_intrep_\STEM\_from_emacs_value (emacs_env * @var{ENV}, emacs_value @var{ARG})
Given the Emacs value @var{ARG}, in the context of the environment @var{ENV}: extract its internal
representation wrapping the C language value; return the representation itself.  The returned value
is independent from @var{ARG}.

If @var{ARG} is not an Emacs built--in value of type @objtype{float}: the @code{wrong-type-argument}
error condition is raised.
@end deftypefun


@deftypefun mmec_clang_\STEM\_t mmec_extract_clang_\STEM\_from_emacs_value (emacs_env * @var{ENV}, emacs_value @var{ARG})
Given the Emacs value @var{ARG}, in the context of the environment @var{ENV}: extract from its
internal representation the raw C language value; return the raw value itself.  The returned value
is independent from the Emacs value @var{ARG}.

If @var{ARG} is not an Emacs built--in value of type @objtype{float}: the @code{wrong-type-argument}
error condition is raised.
@end deftypefun


@deftypefun mmec_clang_\STEM\_t mmec_extract_clang_\STEM\_from_intrep_\STEM\ (mmec_intrep_\STEM\_t @var{IREP})
Given the internal representation of a wrapper for the C language type @code{\CTYPE\}, extract and
return its value as raw C language value.
@end deftypefun

@subsubheading Constructors

@deftypefun mmec_intrep_\STEM\_t mmec_new_intrep_\STEM\_from_clang_\STEM\ (mmec_clang_\STEM\_t @var{VAL})
Given the raw C language value @var{VAL} wrap it into its internal representation and return the
result.  The returned value is independent from @var{VAL}.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_from_intrep_\STEM\ (emacs_env * @var{ENV}, mmec_intrep_\STEM\_t @var{VAL})
Given the internal representation @var{VAL} of a C language value: build and return a new Emacs
value, in the context of the environment @var{ENV}, representing the C language value itself.  The
returned object is independent from @var{VAL}.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_from_clang_\STEM\ (emacs_env * @var{ENV}, mmec_clang_\STEM\_t @var{VAL})
Given a raw C language value: build and return a new Emacs value, in the context of the environment
@var{ENV}, representing the raw value itself.  The returned object is independent from @var{VAL}.
@end deftypefun
@end macro

@c ------------------------------------------------------------------------

@macro DocumentNumberValueWithUsrptrRep{STEM, CTYPE}
@node capi objects clang \STEM\
@subsubsection Wrapper of @code{\CTYPE\}

@deftp {Struct Pointer} mmec_intrep_\STEM\_t
Type of internal representation for objects wrapping a C language value of type @code{\CTYPE\} and
using a user--pointer object as internal representation.
@end deftp

@subsubheading Extractors

@deftypefun mmec_intrep_\STEM\_t mmec_get_intrep_\STEM\_from_emacs_value (emacs_env * @var{ENV}, emacs_value @var{ARG})
Given the Emacs value @var{ARG}, in the context of the environment @var{ENV}: retrieve its internal
representation wrapping the C language value; return the representation.  The returned value is
still dependent from @var{ARG}: if we mutate it, we will mutate the original Emacs value.

If @var{ARG} is not an Emacs user--pointer object: the @code{wrong-type-argument} error condition is
raised.  At the C language level: there is no way to validate @var{ARG} as having an object of type
@objtype{mmec_intrep_\STEM\_t} as internal representation, rather than some other user--pointer
object type.
@end deftypefun


@deftypefun mmec_clang_\STEM\_t mmec_extract_clang_\STEM\_from_emacs_value (emacs_env * @var{ENV}, emacs_value @var{ARG})
Given the Emacs value @var{ARG}, in the context of the environment @var{ENV}: extract from it its
representation the raw C language value; return the value.  The returned value is independent from
the Emacs value @var{ARG}.

If @var{ARG} is not an Emacs user--pointer value: the @code{wrong-type-argument} error condition is
raised.  At the C language level: there is no way to validate @var{ARG} as having an object of type
@objtype{mmec_intrep_\STEM\_t} as internal representation, rather than some other user--pointer
object type.
@end deftypefun


@deftypefun mmec_clang_\STEM\_t mmec_extract_clang_\STEM\_from_intrep_\STEM\ (mmec_intrep_\STEM\_t @var{IREP})
Given the internal representation of a wrapper for the C language type @code{\CTYPE\}, extract and
return its value as raw C language value.  The returned value is independent from the internal
representation @var{IREP}.
@end deftypefun

@subsubheading Constructors

@deftypefun mmec_intrep_\STEM\_t mmec_new_intrep_\STEM\_from_clang_\STEM\ (mmec_clang_\STEM\_t @var{VAL})
Given the raw C language value @var{VAL} wrap it into its internal representation and return the
result.  The returned value is independent from @var{VAL}.

If an error occurs building the internal representation: an error is signalled and the return value
is @cnull{}.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_from_intrep_\STEM\ (emacs_env * @var{ENV}, mmec_intrep_\STEM\_t @var{IREP})
Given the internal representation @var{VAL} of a C language value: build and return a new Emacs
value, in the context of the environment @var{ENV}, representing the C language value.  The returned
object references @var{IREP} itself.
@end deftypefun


@deftypefun emacs_value mmec_new_emacs_value_from_clang_\STEM\ (emacs_env * @var{ENV}, mmec_clang_\STEM\_t @var{VAL})
Given a raw C language value: build and return a new Emacs value, in the context of the environment
@var{ENV}, representing the C language value itself.  The returned object is independent from
@var{VAL}.

If an error occurs building the internal representation: an error is signalled and the return value
is @nil{}.
@end deftypefun
@end macro

@c ------------------------------------------------------------------------

@menu
* capi objects clang char::     Wrapper of @code{char}.
* capi objects clang schar::    Wrapper of @code{signed char}.
* capi objects clang uchar::    Wrapper of @code{unsigned char}.
* capi objects clang wchar::    Wrapper of @code{wchar_t}.
* capi objects clang sshrt::    Wrapper of @code{signed short int}.
* capi objects clang ushrt::    Wrapper of @code{unsigned short int}.
* capi objects clang sint::     Wrapper of @code{signed int}.
* capi objects clang uint::     Wrapper of @code{unsigned int}.
* capi objects clang slong::    Wrapper of @code{signed long int}.
* capi objects clang ulong::    Wrapper of @code{unsigned long int}.
* capi objects clang sllong::   Wrapper of @code{signed long long int}.
* capi objects clang ullong::   Wrapper of @code{unsigned long long int}.
* capi objects clang sintmax::  Wrapper of @code{intmax_t}.
* capi objects clang uintmax::  Wrapper of @code{uintmax_t}.
* capi objects clang ssize::    Wrapper of @code{ssize_t}.
* capi objects clang usize::    Wrapper of @code{size_t}.
* capi objects clang ptrdiff::  Wrapper of @code{ptrdiff_t}.
* capi objects clang sint8::    Wrapper of @code{int8_t}.
* capi objects clang uint8::    Wrapper of @code{uint8_t}.
* capi objects clang sint16::   Wrapper of @code{int16_t}.
* capi objects clang uint16::   Wrapper of @code{uint16_t}.
* capi objects clang sint32::   Wrapper of @code{int32_t}.
* capi objects clang uint32::   Wrapper of @code{uint32_t}.
* capi objects clang sint64::   Wrapper of @code{int64_t}.
* capi objects clang uint64::   Wrapper of @code{uint64_t}.
* capi objects clang float::    Wrapper of @code{float}.
* capi objects clang double::   Wrapper of @code{double}.
* capi objects clang ldouble::  Wrapper of @code{long double}.
@end menu

@DocumentNumberValueWithIntegerRep{char, char}
@DocumentNumberValueWithIntegerRep{schar, signed char}
@DocumentNumberValueWithIntegerRep{uchar, unsigned char}
@DocumentNumberValueWithUsrptrRep{wchar, wchar_t}
@DocumentNumberValueWithIntegerRep{sshrt, signed short int}
@DocumentNumberValueWithIntegerRep{ushrt, unsigned short int}
@DocumentNumberValueWithUsrptrRep{sint, signed int}
@DocumentNumberValueWithUsrptrRep{uint, unsigned int}
@DocumentNumberValueWithUsrptrRep{slong, signed long int}
@DocumentNumberValueWithUsrptrRep{ulong, unsigned long int}
@DocumentNumberValueWithUsrptrRep{sllong, signed long long int}
@DocumentNumberValueWithUsrptrRep{ullong, unsigned long long int}
@DocumentNumberValueWithUsrptrRep{sintmax, intmax_t}
@DocumentNumberValueWithUsrptrRep{uintmax, uintmax_t}
@DocumentNumberValueWithUsrptrRep{ssize, ssize_t}
@DocumentNumberValueWithUsrptrRep{usize, size_t}
@DocumentNumberValueWithUsrptrRep{ptrdiff, ptrdiff_t}
@DocumentNumberValueWithIntegerRep{sint8, int8_t}
@DocumentNumberValueWithIntegerRep{uint8, uint8_t}
@DocumentNumberValueWithIntegerRep{sint16, int16_t}
@DocumentNumberValueWithIntegerRep{uint16, uint16_t}
@DocumentNumberValueWithUsrptrRep{sint32, int32_t}
@DocumentNumberValueWithUsrptrRep{uint32, uint32_t}
@DocumentNumberValueWithUsrptrRep{sint64, int64_t}
@DocumentNumberValueWithUsrptrRep{uint64, uint64_t}
@DocumentNumberValueWithUsrptrRep{float, float}
@DocumentNumberValueWithFloatRep{double, double}
@DocumentNumberValueWithUsrptrRep{ldouble, ldouble}

@c page
@node capi bytevec
@section Bytevector objects


@menu
* capi bytevec typedefs::       Bytevector type definitions.
* capi bytevec ctors::          Bytevector constructors and destructors.
* capi bytevec values::         Constructors and getters for bytevector
                                Emacs values.
* capi bytevec inspect::        Inspecting bytevector objects.
* capi bytevec getters::        Getters for bytevector objects.
* capi bytevec setters::        Setters for bytevector objects.
* capi bytevec comparison::     Comparing bytevector objects.
* capi bytevec operations::     Operations on bytevector objects.
@end menu

@c page
@node capi bytevec typedefs
@subsection Bytevector type definitions


@deftp {Struct Typedef} mmec_intrep_bytevector_t
Structure type for the internal representation of bytevectors as Emacs Lisp values of type
@objtype{mmec-bytevector}.  It has the following fields:

@table @code
@item intmax_t number_of_slots
Non--negative number of slots allocated in the binary data area.

@item intmax_t slot_size
Strictly positive number representing the size in bytes of a slot in the binary data area.

@item bool hold_signed_values
True if the slots hold signed numeric values.

@item void * ptr
Pointer to the binary data area.  Set to @cnull{} if the number of slots is zero.
@end table
@end deftp

@c page
@node capi bytevec ctors
@subsection Bytevector constructors and destructors


@deftypefun {mmec_interp_bytevector_t *} mmec_new_intrep_bytevector (intmax_t @var{number_of_slots}, intmax_t @var{slot_size}, bool @var{hold_signed_values})
Allocate, initialise and return a new bytevector user--pointer object.  If memory allocation fails:
return @cnull{}.
@end deftypefun


@deftypefun void mmec_delete_intrep_bytevector (mmec_intrep_bytevecor_t * @var{bv})
Destructor for user--pointer objects being the internal representation of bytevector objects.  Emacs
Lisp values of type @objtype{mmec-bytevector} are correctly garbage collected, so we must use this
destructor only on user--pointer objects that are not embedded into an Emacs value.
@end deftypefun


@macro ClangDefineBytevectorConstructor{TYPESTEM}
@deftypefun mmec_intrep_bytevector_t * mmec_new_\TYPESTEM\_intrep_bytevector (intmax_t @var{number_of_slots})
Allocate, initialise and return a new bytevector user--pointer object whose binary data area holds
slots of type @code{mmec_clang_\TYPESTEM\_t}.  If memory allocation fails: return @cnull{}.
@end deftypefun

@end macro

@ClangDefineBytevectorConstructor{char}
@ClangDefineBytevectorConstructor{schar}
@ClangDefineBytevectorConstructor{uchar}
@ClangDefineBytevectorConstructor{wchar}
@ClangDefineBytevectorConstructor{sshrt}
@ClangDefineBytevectorConstructor{ushrt}
@ClangDefineBytevectorConstructor{sint}
@ClangDefineBytevectorConstructor{uint}
@ClangDefineBytevectorConstructor{slong}
@ClangDefineBytevectorConstructor{ulong}
@ClangDefineBytevectorConstructor{sllong}
@ClangDefineBytevectorConstructor{ullong}
@ClangDefineBytevectorConstructor{sintmax}
@ClangDefineBytevectorConstructor{uintmax}
@ClangDefineBytevectorConstructor{ssize}
@ClangDefineBytevectorConstructor{usize}
@ClangDefineBytevectorConstructor{ptrdiff}
@ClangDefineBytevectorConstructor{sint8}
@ClangDefineBytevectorConstructor{uint8}
@ClangDefineBytevectorConstructor{sint16}
@ClangDefineBytevectorConstructor{uint16}
@ClangDefineBytevectorConstructor{sint32}
@ClangDefineBytevectorConstructor{uint32}
@ClangDefineBytevectorConstructor{sint64}
@ClangDefineBytevectorConstructor{uint64}
@ClangDefineBytevectorConstructor{float}
@ClangDefineBytevectorConstructor{double}
@ClangDefineBytevectorConstructor{ldouble}

@c page
@node capi bytevec values
@subsection Constructors and getters for bytevector Emacs values


@deftypefun emacs_value mmec_new_emacs_value_from_intrep_bytevector (emacs_env * @var{ENV}, mmec_intrep_bytevector_t * @var{BV})
Build and return a new Emacs user--pointer object representing a bytevector.  The object will have
@var{BV} as its internal representation; mutating @var{BV} will mutate the Emacs user--pointer
object.
@end deftypefun


@deftypefun {mmec_intrep_bytevector_t *} mmec_get_intrep_bytevector_from_emacs_value (emacs_env * @var{ENV}, emacs_value @var{ARG})
Given an Emacs user--pointer object of type @objtype{bytevector} retrieve a pointer to its internal
representation.  The structure referenced by the returned pointer is the actual one used by the
Emacs value: mutating the structure mutates the Emacs value.
@end deftypefun

@c page
@node capi bytevec inspect
@subsection Inspecting bytevector objects


@deftypefun bool mmec_intrep_bytevector_is_empty (mmec_intrep_bytevector_t const * @var{BV})
Return true if the number of slots in the bytevector is zero; otherwise return false.
@end deftypefun


@deftypefun bool mmec_intrep_bytevector_is_not_empty (mmec_intrep_bytevector_t const * @var{BV})
Return true if the number of slots in the bytevector is not zero; otherwise return false.
@end deftypefun


@deftypefun bool mmec_bytevector_valid_slot_index (mmec_intrep_bytevector_t const * @var{BV}, intmax_t @var{idx})
Return true if @var{IDX} is a valid slot index for the bytevector @var{BV}; otherwise return false.
@end deftypefun


@deftypefun bool mmec_bytevector_valid_past_slot_index (mmec_intrep_bytevector_t const * @var{BV}, intmax_t @var{idx})
Return true if @var{IDX} is a valid ``past'' slot index for the bytevector @var{BV}; otherwise
return false.  We can use this function to validate the argument @var{PAST} in the bytevector span
selection.
@end deftypefun


@deftypefun bool mmec_intrep_bytevector_valid_start_and_past (mmec_intrep_bytevector_t const * @var{BV}, intmax_t @var{START}, intmax_t @var{PAST})
Return true if @var{START} and @var{PAST} are valid slot indexes for @var{BV}, that is if the
following condition is true:

@example
0 <= @var{START} <= @var{PAST} <= number of slots
@end example
@end deftypefun

@c page
@node capi bytevec getters
@subsection Getters for bytevector objects


@macro CapiBytevectorGetter{TYPESTEM}
@deftypefun {mmec_clang_\TYPESTEM\_t} mmec_bytevector_\TYPESTEM\_ref (mmec_intrep_bytevector_t const * @var{BV}, intmax_t @var{IDX})
Extract a value of type @code{mmec_clang_\TYPESTEM\_t} from the data area of the bytevector @var{BV}
at slot index @var{IDX}.
@end deftypefun

@end macro


@CapiBytevectorGetter{char}
@CapiBytevectorGetter{schar}
@CapiBytevectorGetter{uchar}
@CapiBytevectorGetter{wchar}
@CapiBytevectorGetter{sshrt}
@CapiBytevectorGetter{ushrt}
@CapiBytevectorGetter{sint}
@CapiBytevectorGetter{uint}
@CapiBytevectorGetter{slong}
@CapiBytevectorGetter{ulong}
@CapiBytevectorGetter{sllong}
@CapiBytevectorGetter{ullong}
@CapiBytevectorGetter{sintmax}
@CapiBytevectorGetter{uintmax}
@CapiBytevectorGetter{ssize}
@CapiBytevectorGetter{usize}
@CapiBytevectorGetter{ptrdiff}
@CapiBytevectorGetter{sint8}
@CapiBytevectorGetter{uint8}
@CapiBytevectorGetter{sint16}
@CapiBytevectorGetter{uint16}
@CapiBytevectorGetter{sint32}
@CapiBytevectorGetter{uint32}
@CapiBytevectorGetter{sint64}
@CapiBytevectorGetter{uint64}
@CapiBytevectorGetter{float}
@CapiBytevectorGetter{double}
@CapiBytevectorGetter{ldouble}

@c page
@node capi bytevec setters
@subsection Setters for bytevector objects


@macro CapiBytevectorSetter{TYPESTEM}
@deftypefun void mmec_bytevector_\TYPESTEM\_set (mmec_intrep_bytevector_t * @var{BV}, intmax_t @var{IDX}, {mmec_clang_\TYPESTEM\_t} @var{VAL})
Store a value of type @code{mmec_clang_\TYPESTEM\_t} in the data area of the bytevector @var{BV} at
slot index @var{IDX}.
@end deftypefun

@end macro


@CapiBytevectorSetter{char}
@CapiBytevectorSetter{schar}
@CapiBytevectorSetter{uchar}
@CapiBytevectorSetter{wchar}
@CapiBytevectorSetter{sshrt}
@CapiBytevectorSetter{ushrt}
@CapiBytevectorSetter{sint}
@CapiBytevectorSetter{uint}
@CapiBytevectorSetter{slong}
@CapiBytevectorSetter{ulong}
@CapiBytevectorSetter{sllong}
@CapiBytevectorSetter{ullong}
@CapiBytevectorSetter{sintmax}
@CapiBytevectorSetter{uintmax}
@CapiBytevectorSetter{ssize}
@CapiBytevectorSetter{usize}
@CapiBytevectorSetter{ptrdiff}
@CapiBytevectorSetter{sint8}
@CapiBytevectorSetter{uint8}
@CapiBytevectorSetter{sint16}
@CapiBytevectorSetter{uint16}
@CapiBytevectorSetter{sint32}
@CapiBytevectorSetter{uint32}
@CapiBytevectorSetter{sint64}
@CapiBytevectorSetter{uint64}
@CapiBytevectorSetter{float}
@CapiBytevectorSetter{double}
@CapiBytevectorSetter{ldouble}

@c page
@node capi bytevec comparison
@subsection Comparing bytevector objects


For all the comparison functions, the arguments @var{START} and @var{PAST} must be valid slot
indexes satisfying the conditions:

@example
0 <= @var{START} <= @var{PAST} <= number of slots
@end example

@noindent
otherwise the behaviour of the functions is undefined.  The functions compare a span in the data
area of the bytevectors starting at slot index @var{START}, included, and ending at slot index
@var{PAST}, excluded.


@deftypefn {Function Prototype} int mmec_intrep_bytevector_compare_fun_t (mmec_intrep_bytevector_t const * @vari{BV}, intmax_t @vari{START}, intmax_t @vari{PAST}, mmec_intrep_bytevector_t const * @vari{BV}, intmax_t @varii{START}, intmax_t @varii{PAST})
Compare the selected spans in the bytevectors @vari{BV} and @varii{BV}, return the following code:

@table @code
@item 0
If the following condition is true:

@example
(@vari{PAST} - @vari{START}) == (@varii{PAST} - @varii{START})
@end example

@noindent
@strong{and} all the values in the slots are equal slot by slot.

@item +1
If the following condition is true:

@example
(@vari{PAST} - @vari{START}) > (@varii{PAST} - @varii{START})
@end example

@noindent
@strong{or}, while visiting the slots from @var{START} to @var{PAST}, @vari{BV} holds a slot value
that is greater than the corresponding slot value in @varii{BV}.

@item -1
If the following condition is true:

@example
(@vari{PAST} - @vari{START}) < (@varii{PAST} - @varii{START})
@end example

@noindent
@strong{or}, while visiting the slots from @var{START} to @var{PAST}, @vari{BV} holds a slot value
that is less than the corresponding slot value in @varii{BV}.
@end table
@end deftypefn


@deftypefn {Function Prototype} bool mmec_intrep_bytevector_comparison_fun_t (mmec_intrep_bytevector_t const * @vari{BV}, intmax_t @vari{START}, intmax_t @vari{PAST}, mmec_intrep_bytevector_t const * @vari{BV}, intmax_t @varii{START}, intmax_t @varii{PAST})
Compare the selected spans in the bytevectors @vari{BV} and @varii{BV}: return @ctrue{} if the
comparison condition is true; otherwise return @cfalse{}.
@end deftypefn

@c ------------------------------------------------------------------------

@macro ClangDefineBytevectorComparison{TYPESTEM}
@deftypefun mmec_intrep_bytevector_compare_fun_t mmec_\TYPESTEM\_intrep_bytevector_compare
@deftypefunx mmec_intrep_bytevector_comparison_fun_t mmec_\TYPESTEM\_intrep_bytevector_equal
@deftypefunx mmec_intrep_bytevector_comparison_fun_t mmec_\TYPESTEM\_intrep_bytevector_less
@deftypefunx mmec_intrep_bytevector_comparison_fun_t mmec_\TYPESTEM\_intrep_bytevector_greater
@deftypefunx mmec_intrep_bytevector_comparison_fun_t mmec_\TYPESTEM\_intrep_bytevector_leq
@deftypefunx mmec_intrep_bytevector_comparison_fun_t mmec_\TYPESTEM\_intrep_bytevector_geq
Comparison function for bytevector user--pointer objects holding values of type
@code{mmec_clang_\TYPESTEM\_t}.
@end deftypefun

@end macro


@ClangDefineBytevectorComparison{char}
@ClangDefineBytevectorComparison{schar}
@ClangDefineBytevectorComparison{uchar}
@ClangDefineBytevectorComparison{wchar}
@ClangDefineBytevectorComparison{sshrt}
@ClangDefineBytevectorComparison{ushrt}
@ClangDefineBytevectorComparison{sint}
@ClangDefineBytevectorComparison{uint}
@ClangDefineBytevectorComparison{slong}
@ClangDefineBytevectorComparison{ulong}
@ClangDefineBytevectorComparison{sllong}
@ClangDefineBytevectorComparison{ullong}
@ClangDefineBytevectorComparison{sintmax}
@ClangDefineBytevectorComparison{uintmax}
@ClangDefineBytevectorComparison{ssize}
@ClangDefineBytevectorComparison{usize}
@ClangDefineBytevectorComparison{ptrdiff}
@ClangDefineBytevectorComparison{sint8}
@ClangDefineBytevectorComparison{uint8}
@ClangDefineBytevectorComparison{sint16}
@ClangDefineBytevectorComparison{uint16}
@ClangDefineBytevectorComparison{sint32}
@ClangDefineBytevectorComparison{uint32}
@ClangDefineBytevectorComparison{sint64}
@ClangDefineBytevectorComparison{uint64}
@ClangDefineBytevectorComparison{float}
@ClangDefineBytevectorComparison{double}
@ClangDefineBytevectorComparison{ldouble}

@c page
@node capi bytevec operations
@subsection Operations on bytevector objects


@deftypefun {mmec_intrep_bytevector_t *} mmec_new_intrep_bytevector_subsequence (mmec_intrep_bytevector_t const * @var{SRC}, intmax_t @var{START}, intmax_t @var{PAST})
Build and return a new bytevector user--pointer object holding a subsequence of the bytevector
referenced by @var{SRC}; the duplicated slots are the ones between index @var{START}, included, and
index @var{PAST}, excluded.  If an error occurs allocating memory: the return value is @cnull{}.

The arguments @var{START} and @var{PAST} must satisfy the conditions:

@example
0 <= @var{START} <= @var{PAST} <= number of slots
@end example

@noindent
otherwise the behaviour of this function is undefined.
@end deftypefun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

We can found informations and examples about Emacs modules at the repository mirror, under the
@file{modules} directory:

@center @url{https://github.com/emacs-mirror/emacs}

There is also a list of resources about Emacs modules:

@center @url{https://github.com/emacs-pe/emacs-modules}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

